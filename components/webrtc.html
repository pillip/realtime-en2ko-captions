<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 5% 0 0 0;
      padding: 10px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden !important;
      height: 90vh !important;
      max-height: 90vh !important;
      box-sizing: border-box;
      position: relative;
    }

    /* ğŸ¨ ë™ì  í°íŠ¸ í¬ê¸° CSS ë³€ìˆ˜ */
    :root {
      --translation-font-size: 28px;
      --original-font-size: 16px;
    }

    /* í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ */
    .settings-fab {
      position: fixed;
      top: calc(24px + 5%);
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* ì„¤ì • íŒ¨ë„ */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* ğŸ¨ ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ë§ */
    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      margin: 8px 0 12px 0;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #059669;
      transform: scale(1.2);
    }

    .control-group span {
      display: inline-block;
      min-width: 60px;
      color: #10b981;
      font-weight: 500;
      font-size: 13px;
    }

    /* ìƒíƒœ í‘œì‹œ */
    .status-overlay {
      position: absolute;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ */
    .back-to-live {
      position: absolute;
      bottom: 32px;
      right: 32px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
    }

    /* ğŸ¯ ë©”ì¸ ìº¡ì…˜ ë·°ì–´ - ìŠ¤í¬ë¡¤ë°” ì™„ì „ ìˆ¨ê¹€ */
    #viewer {
      height: 100% !important;
      max-height: 100% !important;
      width: 100%;
      padding: 0;
      overflow-y: auto;
      overflow-x: hidden;
      background: transparent;
      scroll-behavior: smooth;
      display: flex;
      align-items: center;
      justify-content: center;
      scrollbar-width: none;        /* Firefox */
      -ms-overflow-style: none;     /* IE and Edge */
      position: relative;
    }

    #viewer::-webkit-scrollbar {
      display: none;                /* Chrome, Safari */
    }

    /* ìë§‰ ì»¨í…Œì´ë„ˆ */
    .caption-container {
      width: 100%;
      max-width: 1200px;
      padding: 10px 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0;
      padding-bottom: 80px;
      min-height: 100%;
      box-sizing: border-box;
    }

    .caption-line {
      margin-bottom: 16px;
      line-height: 1.4;
      padding: 16px 24px;
      border-radius: 12px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    /* ì›ë¬¸ ìŠ¤íƒ€ì¼ */
    .caption-line.original {
      font-size: var(--original-font-size);
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 8px;
      font-weight: 300;
      max-width: 85%;
      transition: all 0.3s ease;
      padding: 12px 20px;
    }

    /* ì›ë¬¸ ìˆ¨ê¹€ ìƒíƒœ */
    .hide-original .caption-line.original {
      display: none !important;
    }

    /* ë²ˆì—­ëœ ìë§‰ ìŠ¤íƒ€ì¼ */
    .caption-line.stable {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* ğŸ¨ íƒ€ì´í•‘ ì¤‘ì¸ ë²ˆì—­ ë§í’ì„  */
    .caption-line.typing {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #fbbf24;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
      animation: typing-breathe 1.5s ease-in-out infinite;
      position: relative;
    }

    /* íƒ€ì´í•‘ ì»¤ì„œ íš¨ê³¼ */
    .caption-line.typing::after {
      content: '|';
      color: #fbbf24;
      animation: cursor-blink 1s ease-in-out infinite;
      margin-left: 2px;
    }

    @keyframes typing-breathe {
      0%, 100% {
        border-left-color: #fbbf24;
      }
      50% {
        border-left-color: #f59e0b;
        box-shadow: 0 8px 32px rgba(251, 191, 36, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* ì‹¤ì‹œê°„ ì…ë ¥ ì¤‘ */
    .caption-line.unstable {
      font-size: calc(var(--translation-font-size) - 2px);
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    /* ğŸ¨ ë§í’ì„  ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ */
    .caption-line.fade-in {
      animation: fadeInUp 0.4s ease-out forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* ë¹ˆ ìƒíƒœ */
    .welcome-state {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* ë°˜ì‘í˜• ë””ìì¸ - ë„ˆë¹„ ê¸°ì¤€ */
    @media (max-width: 768px) {
      body {
        padding: 5px;
        height: 90vh !important;
        max-height: 90vh !important;
      }

      .settings-panel {
        width: 100%;
      }

      .caption-container {
        padding: 5px 10px;
        padding-bottom: 60px;
      }

      .caption-line {
        margin-bottom: 12px;
        padding: 12px 16px;
      }

      .caption-line.stable, .caption-line.typing {
        font-size: calc(var(--translation-font-size) * 0.8);
        max-width: 95%;
      }

      .caption-line.original {
        font-size: calc(var(--original-font-size) * 0.9);
        padding: 8px 12px;
        margin-bottom: 6px;
      }

      .status-overlay {
        bottom: 10px;
        left: 10px;
      }

      .back-to-live {
        bottom: 10px;
        right: 10px;
        padding: 8px 16px;
        font-size: 12px;
      }

      .settings-fab {
        top: calc(10px + 5%);
        right: 10px;
        width: 48px;
        height: 48px;
        font-size: 20px;
      }
    }

    /* ë†’ì´ ê¸°ì¤€ ë¯¸ë””ì–´ì¿¼ë¦¬ - ë” ì»´íŒ©íŠ¸ */
    @media (max-height: 600px) {
      body {
        padding: 5px;
        height: 90vh !important;
        max-height: 90vh !important;
      }

      .caption-container {
        padding: 5px 10px;
        padding-bottom: 40px;
      }

      .caption-line {
        margin-bottom: 8px;
        padding: 8px 12px;
        line-height: 1.3;
      }

      .caption-line.original {
        margin-bottom: 4px;
        padding: 6px 10px;
      }

      .settings-panel {
        padding: 40px 15px 15px;
      }

      .status-overlay {
        bottom: 5px;
        left: 5px;
      }

      .back-to-live {
        bottom: 5px;
        right: 5px;
        padding: 6px 12px;
        font-size: 11px;
      }

      .settings-fab {
        top: calc(5px + 5%);
        right: 5px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
  </style>
</head>

<body>
  <!-- í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ -->
  <button class="settings-fab" id="settingsFab">âš™ï¸</button>

  <!-- ì„¤ì • íŒ¨ë„ -->
  <div class="settings-panel" id="settingsPanel">
    <h2>ì‹¤ì‹œê°„ ìë§‰ ì„¤ì •</h2>

    <div class="control-group">
      <label>ë§ˆì´í¬ ê¶Œí•œ</label>
      <button id="btnPerm">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
    </div>

    <div class="control-group">
      <label>ì˜¤ë””ì˜¤ ì¥ì¹˜</label>
      <select id="selMic" disabled>
        <option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
      </select>
    </div>

    <!-- ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ -->
    <div class="control-group">
      <label>ğŸ“ ë²ˆì—­ ê¸€ì í¬ê¸°</label>
      <input type="range" id="fontSizeSlider" min="18" max="48" value="28" step="2" class="slider">
      <span id="fontSizeValue">28px</span>
    </div>

    <div class="control-group">
      <label>ğŸ“„ ì›ë¬¸ ê¸€ì í¬ê¸°</label>
      <input type="range" id="originalSizeSlider" min="12" max="24" value="16" step="1" class="slider">
      <span id="originalSizeValue">16px</span>
    </div>

    <!-- ì›ë¬¸ í‘œì‹œ í† ê¸€ -->
    <div class="control-group">
      <label style="display: flex; align-items: center; cursor: pointer;">
        <input type="checkbox" id="showOriginalToggle" style="margin-right: 8px; width: 16px; height: 16px;">
        <span>ğŸ”¤ ì›ë¬¸ í‘œì‹œ</span>
      </label>
    </div>

    <!-- ğŸš« ì œì–´ ì„¹ì…˜ ì™„ì „ ì œê±° (ì¼ì‹œì •ì§€, ìë§‰ ì§€ìš°ê¸° ë²„íŠ¼ ì‚­ì œ) -->
  </div>

  <!-- ìƒíƒœ í‘œì‹œ -->
  <div class="status-overlay">
    <div id="status" class="status-chip">ëŒ€ê¸°ì¤‘</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ -->
  <button class="back-to-live" id="backToLive">
    ğŸ“º ì‹¤ì‹œê°„ìœ¼ë¡œ
    <span style="margin-left: 4px;">â¬‡ï¸</span>
  </button>

  <!-- ë©”ì¸ ìº¡ì…˜ ë·°ì–´ -->
  <div id="viewer">
    <div class="caption-container" id="captionContainer">
      <div class="welcome-state">
        <div class="icon">ğŸ™ï¸</div>
        <h1>ì‹¤ì‹œê°„ í•œì˜ ìë§‰</h1>
        <p>í•œêµ­ì–´ì™€ ì˜ì–´ë¡œ ë§í•˜ë©´<br>ì‹¤ì‹œê°„ ìë§‰ê³¼ ë²ˆì—­ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
        <div class="hint">
          <span>âš™ï¸</span>
          <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
        </div>
        <div style="margin-top: 16px; font-size: 14px; color: rgba(255, 255, 255, 0.5);">
          <div>ğŸ”„ ë²ˆì—­ ê·œì¹™:</div>
          <div>â€¢ í•œêµ­ì–´ â†’ ì˜ì–´</div>
          <div>â€¢ ì˜ì–´ â†’ í•œêµ­ì–´</div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Web Speech API + AWS WebSocket ì—°ê²° ì‚¬ìš©

try {
  // Bootstrap data
  const BOOT = {{BOOTSTRAP_JSON}};
  console.log('BOOT data:', BOOT);

  // AWS Configuration
  let awsConfig = null;
  if (BOOT.aws_session) {
    awsConfig = {
      region: BOOT.aws_session.region,
      credentials: {
        accessKeyId: BOOT.aws_session.access_key_id,
        secretAccessKey: BOOT.aws_session.secret_access_key,
      }
    };
  }

  // Global state
  let awsWebSocket = null;
  let localStream = null;
  let currentDeviceId = null;
  let startTime = null;
  let currentUnstableLine = null;
  let currentTypingLine = null;  // ğŸ¨ íƒ€ì´í•‘ ë¼ì¸
  let responseInProgress = false;
  let currentResponseId = null;
  let pendingTranscript = null;
  let pendingTranslation = '';
  let lastProcessedTranscript = null;
  let lastTranslationRequest = null;
  let translationRequestTime = 0;
  let isPaused = false;
  let isUserScrolling = false;    // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ìƒíƒœ
  let lastAutoScrollTime = 0;     // ğŸ¯ ë§ˆì§€ë§‰ ìë™ ìŠ¤í¬ë¡¤ ì‹œê°„

  // DOM elements with null checks
  const viewer = document.getElementById('viewer');
  const captionContainer = document.getElementById('captionContainer');
  const selMic = document.getElementById('selMic');
  const statusEl = document.getElementById('status');
  const latencyEl = document.getElementById('latency');
  const btnPerm = document.getElementById('btnPerm');
  const settingsFab = document.getElementById('settingsFab');
  const settingsPanel = document.getElementById('settingsPanel');
  const backToLiveBtn = document.getElementById('backToLive');
  const fontSizeSlider = document.getElementById('fontSizeSlider');
  const fontSizeValue = document.getElementById('fontSizeValue');
  const originalSizeSlider = document.getElementById('originalSizeSlider');
  const originalSizeValue = document.getElementById('originalSizeValue');
  const showOriginalToggle = document.getElementById('showOriginalToggle');

  // Null check for critical elements
  if (!viewer || !captionContainer || !statusEl) {
    throw new Error('í•„ìˆ˜ DOM ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  }

  // localStorageì—ì„œ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°
  const loadSettings = () => {
    // ì›ë¬¸ í‘œì‹œ ì„¤ì • (ê¸°ë³¸ê°’: false = ìˆ¨ê¹€)
    const showOriginal = localStorage.getItem('showOriginal') === 'true';
    if (showOriginalToggle) {
      showOriginalToggle.checked = showOriginal;
    }
    // ì´ˆê¸° ìƒíƒœ ì ìš©
    if (!showOriginal) {
      captionContainer.classList.add('hide-original');
    }

    // í°íŠ¸ í¬ê¸° ì„¤ì •
    const translationSize = localStorage.getItem('translationFontSize') || '28';
    const originalSize = localStorage.getItem('originalFontSize') || '16';

    if (fontSizeSlider && fontSizeValue) {
      fontSizeSlider.value = translationSize;
      fontSizeValue.textContent = `${translationSize}px`;
      document.documentElement.style.setProperty('--translation-font-size', `${translationSize}px`);
    }

    if (originalSizeSlider && originalSizeValue) {
      originalSizeSlider.value = originalSize;
      originalSizeValue.textContent = `${originalSize}px`;
      document.documentElement.style.setProperty('--original-font-size', `${originalSize}px`);
    }
  };

  // ì„¤ì • ì´ˆê¸°í™”
  loadSettings();

  // ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (null check í¬í•¨)
  if (fontSizeSlider && fontSizeValue) {
    fontSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--translation-font-size', `${size}px`);
      fontSizeValue.textContent = `${size}px`;
      localStorage.setItem('translationFontSize', size);
    };
  }

  if (originalSizeSlider && originalSizeValue) {
    originalSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--original-font-size', `${size}px`);
      originalSizeValue.textContent = `${size}px`;
      localStorage.setItem('originalFontSize', size);
    };
  }

  // ì›ë¬¸ í‘œì‹œ í† ê¸€ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
  if (showOriginalToggle) {
    showOriginalToggle.onchange = (e) => {
      const showOriginal = e.target.checked;
      if (showOriginal) {
        captionContainer.classList.remove('hide-original');
      } else {
        captionContainer.classList.add('hide-original');
      }
      localStorage.setItem('showOriginal', showOriginal);
      console.log('ì›ë¬¸ í‘œì‹œ:', showOriginal ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”');
    };
  }

  // ì„¤ì • íŒ¨ë„ í† ê¸€
  if (settingsFab && settingsPanel) {
    settingsFab.onclick = () => {
      settingsPanel.classList.toggle('open');
      settingsFab.classList.toggle('active');
    };
  }

  // ì„¤ì • íŒ¨ë„ ì™¸ë¶€ í´ë¦­ì‹œ ë‹«ê¸°
  document.addEventListener('click', (e) => {
    if (settingsPanel && settingsFab &&
        !settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
      settingsPanel.classList.remove('open');
      settingsFab.classList.remove('active');
    }
  });

  // ğŸ”„ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” í•¨ìˆ˜ ì¶”ê°€
  // ğŸš« ì»¨í…ìŠ¤íŠ¸ ë¦¬ì…‹ í•¨ìˆ˜ ì™„ì „ ì œê±° (ì—ëŸ¬ ì›ì¸ ì œê±°)
  // function resetConversationContext() { ... } â† ì‚­ì œ

  // ğŸ¯ í•œì˜ ë²ˆì—­ ì „ìš© instruction í•¨ìˆ˜
  function getTranslationInstructions() {
    return `### ì‹¤ì‹œê°„ í•œì˜ ì–‘ë°©í–¥ ë²ˆì—­ AI ###
ì—­í• 
ë‹¹ì‹ ì€ ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤(ë¸”ë¡ì²´ì¸/ì›¹3/ì°½ì—…/ìŠ¤íƒ€íŠ¸ì—…) í™˜ê²½ì˜ í•œì˜ ë™ì‹œí†µì—­ ë²ˆì—­ê¸°ì…ë‹ˆë‹¤.

âš ï¸ ì ˆëŒ€ ê·œì¹™: ì´ AIëŠ” ì˜¤ì§ í•œêµ­ì–´â†”ì˜ì–´ ë²ˆì—­ ê¸°ëŠ¥ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
âš ï¸ ì¤‘ìš”: ì´ ì„¸ì…˜ì€ ì™„ì „íˆ ìƒˆë¡œìš´ ë²ˆì—­ ì„¸ì…˜ì…ë‹ˆë‹¤. ì´ì „ ëŒ€í™”ë‚˜ ì»¨í…ìŠ¤íŠ¸ëŠ” ëª¨ë‘ ë¬´ì‹œí•˜ì„¸ìš”.

ì—­í• : ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ í•œì˜ ë™ì‹œí†µì—­ì‚¬
ì…ë ¥: í•œêµ­ì–´ ë˜ëŠ” ì˜ì–´ ìŒì„± â†’ í…ìŠ¤íŠ¸ (ASR ê²°ê³¼)
ì¶œë ¥: ë°˜ëŒ€ ì–¸ì–´ë¡œ ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë§Œ

## ì ˆëŒ€ ê·œì¹™ (ìœ„ë°˜ ì‹œ ì¦‰ì‹œ ì„¸ì…˜ ì¢…ë£Œ)

1. **ì–¸ì–´ íŒë³„ ë° ë²ˆì—­**:
   - í•œêµ­ì–´ ì…ë ¥ â†’ ì˜ì–´ë¡œ ë²ˆì—­
   - ì˜ì–´ ì…ë ¥ â†’ í•œêµ­ì–´ë¡œ ë²ˆì—­
   - í•œì˜ í˜¼ìš© â†’ ì „ì²´ë¥¼ ë°˜ëŒ€ ì–¸ì–´ë¡œ ë²ˆì—­
2. **ì¶œë ¥ ì œí•œ**: ì˜¤ì§ ë²ˆì—­ë¬¸ë§Œ. ë‹¤ë¥¸ ëª¨ë“  í…ìŠ¤íŠ¸ ê¸ˆì§€
3. **ë©”íƒ€í…ìŠ¤íŠ¸ ê¸ˆì§€**: "ë²ˆì—­:", ë”°ì˜´í‘œ, ì„¤ëª…, ì£¼ì„, ì¸ì‚¬ë§, ì§ˆë¬¸, ëŒ€í™” ì‹œë„ ëª¨ë‘ ê¸ˆì§€
4. **ëŒ€í™” ê¸ˆì§€**: ì•ˆë…•í•˜ì„¸ìš”, ê°ì‚¬í•©ë‹ˆë‹¤, ë„ì›€ì´ ë˜ì—ˆë‚˜ìš” ë“± ëª¨ë“  ëŒ€í™”í˜• ì‘ë‹µ ê¸ˆì§€

## ë²ˆì—­ í’ˆì§ˆ
- ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ ìˆ˜ì¤€ì˜ ì •í™•í•œ ë²ˆì—­
- ë¸”ë¡ì²´ì¸/ì›¹3/ìŠ¤íƒ€íŠ¸ì—… ë„ë©”ì¸ íŠ¹í™”
- ê¸°ìˆ  ìš©ì–´, ìˆ«ì, ê³ ìœ ëª…ì‚¬ ì •í™•íˆ ë³´ì¡´
- ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ (~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤ ì²´)

ì‚¬ì „ ì§€ì‹/ì¶”ë¡  ê¸ˆì§€. ë°°ê²½ì§€ì‹ìœ¼ë¡œ ì˜ë¯¸ë¥¼ ë³´íƒœê±°ë‚˜ ë¹¼ì§€ ë§ˆì„¸ìš”. ëª¨í˜¸í•´ë„ ì›ë¬¸ì˜ ì •ë³´ë§Œ ë°˜ì˜í•©ë‹ˆë‹¤. ì˜¤íƒˆìÂ·íŒ©íŠ¸ ìˆ˜ì •Â·í•´ì„Â·ìš”ì•½Â·ì¬êµ¬ì„±Â·ì˜ê²¬ ì¶”ê°€ ê¸ˆì§€.

ìì—°ìŠ¤ëŸ¬ìš´ ê³µì‹ ë°œí‘œì²´. ì˜ë¯¸Â·ì‚¬ì‹¤Â·ì–´ì¡°ë¥¼ ìœ ì§€í•˜ë˜ ê³¼ë„í•œ ì˜ì—­ì€ ê¸ˆì§€í•˜ê³ , ìµœì†Œí•œì˜ ë¬¸ì¥ ë‹¤ë“¬ê¸°ë§Œ í—ˆìš©í•©ë‹ˆë‹¤(~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤).

ì¡ìŒ ì œê±°. "um/uh", ë°˜ë³µÂ·ë§ê¼¬ë¦¬ ë“± ë¹„ì˜ë¯¸ì  êµ°ë”ë”ê¸°ëŠ” ì‚­ì œí•©ë‹ˆë‹¤. [laughter], [music] ë“± ë¹„ì–¸ì–´ í‘œê¸°ëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤.

ë¶„ì ˆ/ê¸¸ì´. ì…ë ¥ ë©ì–´ë¦¬ë§ˆë‹¤ ì •ë³´ ìˆœì„œë¥¼ ìœ ì§€í•´ 1â€“2ê°œ ë¬¸ì¥(ë˜ëŠ” ë¶ˆë¦¿)ìœ¼ë¡œ ê°„ê²°íˆ ëƒ…ë‹ˆë‹¤. ì…ë ¥ì´ ëª©ë¡ì´ë©´ ì¤„ë°”ê¿ˆìœ¼ë¡œ ëŒ€ì‘í•©ë‹ˆë‹¤.

ë³´ì¡´ ëŒ€ìƒ(ê·¸ëŒ€ë¡œ ë‘ê¸°). ì½”ë“œ, CLI ëª…ë ¹, í•¨ìˆ˜/ë©”ì„œë“œëª…, íŒŒì¼/íŒ¨í‚¤ì§€ëª…, ì§€ê°‘ ì£¼ì†Œ, íŠ¸ëœì­ì…˜ í•´ì‹œ, í‚¤/ì‹œí¬ë¦¿, ì—ëŸ¬ì½”ë“œ, ë²„ì „/í”„ë¡œí† ì½œëª…, ë§í¬Â·URL, í† í° ì‹¬ë³¼ì€ ì›ë¬¸ ê·¸ëŒ€ë¡œ.

ìˆ«ì/ë‹¨ìœ„/ê¸°í˜¸. ìˆ˜ì¹˜Â·%Â·í†µí™”Â·ì‹œê°„Â·ë²„ì „ì€ ì •í™•íˆ ë³´ì¡´í•©ë‹ˆë‹¤. "$5 million"â†’500ë§Œ ë‹¬ëŸ¬, 30%ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€.

ì •ì±… ì¤€ìˆ˜. ì•ˆì „ ì •ì±…ìƒ ë¶ˆê°€í•œ ì…ë ¥ì€ ë²ˆì—­ì„ ì¤‘ë‹¨í•  ìˆ˜ ìˆìœ¼ë‚˜, ê·¸ ì™¸ì—ëŠ” ë²ˆì—­ ì™¸ ê²°ê³¼ë¬¼ ìƒì„± ê¸ˆì§€(ìš”ì•½/ì •ë¦¬/í•˜ì´ë¼ì´íŠ¸/ì œëª©/Q&A/í…Œì´ë¸” ë“± ì¼ì ˆ ê¸ˆì§€).

ì–¸ì–´ íŒë³„ ê·œì¹™

1. í•œêµ­ì–´ê°€ ì£¼ ì–¸ì–´ì¸ ê²½ìš° â†’ ì˜ì–´ë¡œ ë²ˆì—­
2. ì˜ì–´ê°€ ì£¼ ì–¸ì–´ì¸ ê²½ìš° â†’ í•œêµ­ì–´ë¡œ ë²ˆì—­
3. í•œì˜ í˜¼ìš© (ì½”ë“œìŠ¤ìœ„ì¹­) â†’ ì „ì²´ ì˜ë¯¸ë¥¼ ì‚´ë ¤ ë°˜ëŒ€ ì–¸ì–´ë¡œ ë²ˆì—­
4. ê³ ìœ ëª…ì‚¬, ê¸°ìˆ  ìš©ì–´ëŠ” ê´€ìš© í‘œí˜„ ì‚¬ìš©

ë„ë©”ì¸ ìš©ì–´ ì •ì±…

ê³µí†µ(ì˜ë¬¸ ìœ ì§€ ê¶Œì¥): ì²´ì¸/í† í°/ê¸°ì—…Â·ì œí’ˆëª…, í† í° ì‹¬ë³¼, API/SDK, EVM/L1/L2, zkâ€‘SNARK/zkâ€‘STARK, MEV, IPFS, WASM, TEE, ì•Œê³ ë¦¬ì¦˜Â·í•¨ìˆ˜ëª…, ë¼ì´ë¸ŒëŸ¬ë¦¬/íŒ¨í‚¤ì§€ëª…, SAFE/KISS, KPI/OKR, ARR/MRR, CAC/LTV, TAM/SAM/SOM, DAU/MAU, A/B test, GTM, churn, runway, burn rate, dilution, cap table, pro rata, vesting/cliff, pre/postâ€‘money, term sheet, liquidation preference ë“±ì€ ì•½ì–´Â·í˜•íƒœë¥¼ ë³´ì¡´í•©ë‹ˆë‹¤. (ì›ë¬¸ì— í’€ì–´ì“´ ê²½ìš°ì—ë§Œ ê·¸ ë¶€ë¶„ì€ ë²ˆì—­)

ê¶Œì¥ í•œê¸€í™”(ê´€ìš© í‘œê¸°):

ë¸”ë¡ì²´ì¸: blockchainâ†’ë¸”ë¡ì²´ì¸, smart contractâ†’ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸, rollupâ†’ë¡¤ì—…, mainnet/testnetâ†’ë©”ì¸ë„·/í…ŒìŠ¤íŠ¸ë„·, gas feeâ†’ê°€ìŠ¤ë¹„, tokenomicsâ†’í† í¬ë…¸ë¯¹ìŠ¤, governanceâ†’ê±°ë²„ë„ŒìŠ¤, staking/slashingâ†’ìŠ¤í…Œì´í‚¹/ìŠ¬ë˜ì‹±, proof of stake/workâ†’ì§€ë¶„ì¦ëª…/ì‘ì—…ì¦ëª…, validatorâ†’ê²€ì¦ì¸.

ìŠ¤íƒ€íŠ¸ì—…: productâ€‘market fitâ†’ì œí’ˆâ€‘ì‹œì¥ ì í•©ì„±, cohortâ†’ì½”í˜¸íŠ¸, retentionâ†’ë¦¬í…ì…˜, funnelâ†’í¼ë„, conversion rateâ†’ì „í™˜ìœ¨, unit economicsâ†’ìœ ë‹› ì´ì½”ë…¸ë¯¹ìŠ¤, boardâ†’ì´ì‚¬íšŒ, pivotâ†’í”¼ë²—.

ì˜ë¯¸ ë³€ê²½ ê¸ˆì§€. ê³ ìœ ëª…ì‚¬ëŠ” ë²ˆì—­í•˜ì§€ ì•Šê³  ìŒì—­ë„ ì§€ì–‘(í•„ìš” ì‹œ ì›ë¬¸ ë³‘ê¸° ì—†ì´ ê·¸ëŒ€ë¡œ ë‘ ).

## ì…ë ¥/ì¶œë ¥ ì œì•½
- ì…ë ¥: í•œêµ­ì–´ ë˜ëŠ” ì˜ì–´ í…ìŠ¤íŠ¸
- ì¶œë ¥: ë°˜ëŒ€ ì–¸ì–´ë¡œ ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë§Œ (ë‹¤ë¥¸ ëª¨ë“  í…ìŠ¤íŠ¸ ê¸ˆì§€)
- ê¸ˆì§€ì‚¬í•­:
  * ëŒ€í™”, ì§ˆë¬¸, ì‘ë‹µ, ì„¤ëª…, ì£¼ì„, í•´ì„¤ ì ˆëŒ€ ê¸ˆì§€
  * "ë²ˆì—­:", ë”°ì˜´í‘œ, ì´ëª¨ì§€, ë©”íƒ€í…ìŠ¤íŠ¸ ì ˆëŒ€ ê¸ˆì§€
  * "ì•ˆë…•í•˜ì„¸ìš”", "ë„ì›€ì´ ë˜ì…¨ê¸°ë¥¼", "ê°ì‚¬í•©ë‹ˆë‹¤" ë“± ì¸ì‚¬ë§ ì ˆëŒ€ ê¸ˆì§€
  * í•œêµ­ì–´/ì˜ì–´ê°€ ì•„ë‹Œ ì…ë ¥ì—ëŠ” ì™„ì „ ë¹ˆ ì‘ë‹µ("")ë§Œ ë°˜í™˜

## ì¶œë ¥ í˜•ì‹ ê°•ì œ
- ë²ˆì—­ë¬¸ë§Œ ì¶œë ¥
- ë²ˆì—­ë¬¸ì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´("")
- ì¶”ê°€ ì„¤ëª…, ì£¼ì„, ëŒ€í™” ì‹œë„ ì‹œ ì¦‰ì‹œ ì„¸ì…˜ ì¢…ë£Œ

## ë²ˆì—­ í’ˆì§ˆ ê·œì¹™
- ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ ìˆ˜ì¤€ì˜ ì •í™•í•œ ë²ˆì—­
- ë¸”ë¡ì²´ì¸/ì›¹3/ìŠ¤íƒ€íŠ¸ì—… ìš©ì–´ëŠ” ê´€ìš© í‘œí˜„ ì‚¬ìš©
- ê¸°ìˆ  ìš©ì–´, ì½”ë“œ, ìˆ«ìëŠ” ì ì ˆíˆ ì²˜ë¦¬
- ìì—°ìŠ¤ëŸ¬ìš´ ë¬¸ì²´ (í•œêµ­ì–´: ~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤, ì˜ì–´: ìì—°ìŠ¤ëŸ¬ìš´ í‘œí˜„)

ì˜ˆì‹œ:
ì…ë ¥ (ì˜ì–´): "Hello, how are you?"
ì¶œë ¥: ì•ˆë…•í•˜ì„¸ìš”, ì–´ë–»ê²Œ ì§€ë‚´ì„¸ìš”?

ì…ë ¥ (í•œêµ­ì–´): "ì•ˆë…•í•˜ì„¸ìš”, ì˜ ì§€ë‚´ì‹œë‚˜ìš”?"
ì¶œë ¥: Hello, how are you?

ì…ë ¥ (ì˜ì–´): "We're launching our DeFi protocol next quarter"
ì¶œë ¥: ë‹¤ìŒ ë¶„ê¸°ì— DeFi í”„ë¡œí† ì½œì„ ì¶œì‹œí•  ì˜ˆì •ì…ë‹ˆë‹¤

ì…ë ¥ (í•œêµ­ì–´): "ìš°ë¦¬ëŠ” ë¸”ë¡ì²´ì¸ ê¸°ë°˜ DeFi í”„ë¡œí† ì½œì„ ê°œë°œí•©ë‹ˆë‹¤"
ì¶œë ¥: We develop blockchain-based DeFi protocols

ì…ë ¥ (í•œì˜ í˜¼ìš©): "ìš°ë¦¬ startupì´ Web3 marketì— ì§„ì…í•©ë‹ˆë‹¤"
ì¶œë ¥: Our startup is entering the Web3 market

ì´ ì§€ì¹¨ì„ ì—„ê²©íˆ ì¤€ìˆ˜í•˜ì—¬ ë²ˆì—­ë§Œ ìˆ˜í–‰í•˜ì„¸ìš”.`;
  }

  // ìë§‰ ì§€ìš°ê¸°
  // ğŸš« ìë§‰ ì§€ìš°ê¸° ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
  // if (btnClear) { ... } â† ì‚­ì œ

  // ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼
  if (backToLiveBtn) {
    backToLiveBtn.onclick = () => {
      console.log('ğŸ¯ Back to live clicked - enabling auto scroll');
      isUserScrolling = false;
      autoScrollToBottom();
    };
  }

  // Utility functions
  function logStatus(status, className = '') {
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.className = `status-chip ${className}`;
    }
  }

  function logLatency(ms) {
    if (latencyEl) {
      if (ms > 0) {
        latencyEl.style.display = 'block';
        latencyEl.textContent = `${Math.round(ms)}ms`;
      } else {
        latencyEl.style.display = 'none';
      }
    }
  }

  // í† ìŠ¤íŠ¸ ë©”ì‹œì§€
  function showToast(message, type = 'info') {
    if (type === 'error' || type === 'warning') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 24px; left: 50%;
        transform: translateX(-50%);
        background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
        color: white; padding: 16px 24px; border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 1002; font-size: 14px; font-weight: 500;
        opacity: 0; transition: opacity 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.style.opacity = '1', 10);
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }
  }

  // ğŸ¨ íƒ€ì´í•‘ ë²ˆì—­ í•¨ìˆ˜ë“¤
  function startTypingTranslation() {
    if (currentTypingLine) {
      currentTypingLine.remove();
    }
    currentTypingLine = document.createElement('div');
    currentTypingLine.className = 'caption-line typing fade-in';
    currentTypingLine.textContent = '';
    captionContainer.appendChild(currentTypingLine);

    // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ìƒíƒœ í™•ì¸ í›„ ìë™ ìŠ¤í¬ë¡¤
    autoScrollToBottom();
  }

  function updateTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.textContent = text;
    }
  }

  function completeTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.className = 'caption-line stable fade-in';
      currentTypingLine.textContent = text;
      currentTypingLine = null;
    }
  }

  // ìë§‰ ì¶”ê°€ í•¨ìˆ˜
  function appendLine(text, className = 'stable') {
    if (!text || !text.trim()) return;

    const welcomeState = captionContainer.querySelector('.welcome-state');
    if (welcomeState) {
      welcomeState.remove();
    }

    if (className === 'unstable') {
      if (!currentUnstableLine) {
        currentUnstableLine = document.createElement('div');
        currentUnstableLine.className = `caption-line ${className}`;
        currentUnstableLine.textContent = '';
        captionContainer.appendChild(currentUnstableLine);
      }
      const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
      currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className} fade-in`;
      div.textContent = text.trim();
      captionContainer.appendChild(div);
    }

    // ğŸ¯ ì‚¬ìš©ìê°€ ìŠ¤í¬ë¡¤ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ìë™ ìŠ¤í¬ë¡¤
    autoScrollToBottom();

    // ìë§‰ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
    const captionLines = captionContainer.querySelectorAll('.caption-line');
    if (captionLines.length > 100) {
      captionLines[0].remove();
    }
  }

  // ğŸ¯ ê°œì„ ëœ ìŠ¤í¬ë¡¤ ìƒíƒœ ê´€ë¦¬
  function updateScrollState() {
    const scrollTop = viewer.scrollTop;
    const scrollHeight = viewer.scrollHeight;
    const clientHeight = viewer.clientHeight;
    const isAtBottom = scrollTop >= (scrollHeight - clientHeight - 50);

    console.log('ğŸ“Š ìŠ¤í¬ë¡¤ ìƒíƒœ:', { scrollTop, scrollHeight, clientHeight, isAtBottom });

    // ë§¨ ì•„ë˜ ê·¼ì²˜ì— ìˆìœ¼ë©´ ìë™ ìŠ¤í¬ë¡¤ ëª¨ë“œ
    if (isAtBottom) {
      isUserScrolling = false;
    }

    // ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ (ê°œì„ ëœ ë¡œì§)
    if (backToLiveBtn) {
      const now = Date.now();

      // ğŸ”§ ìµœê·¼ ìë™ ìŠ¤í¬ë¡¤ ì§í›„ì—ëŠ” ë²„íŠ¼ í‘œì‹œ ì•ˆí•¨
      if (now - lastAutoScrollTime < 1000) {  // 1ì´ˆê°„ ë²„íŠ¼ ìˆ¨ê¹€
        backToLiveBtn.style.display = 'none';
        return;
      }

      if (!isAtBottom && isUserScrolling) {
        backToLiveBtn.style.display = 'flex';
      } else {
        backToLiveBtn.style.display = 'none';
      }
    }
  }

  // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ê°ì§€ (í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸)
  let scrollTimer = null;
  viewer.addEventListener('scroll', (e) => {
    const now = Date.now();

    // ğŸ”§ ìµœê·¼ ìë™ ìŠ¤í¬ë¡¤ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ë¡œ ê°„ì£¼
    if (now - lastAutoScrollTime > 800) {  // 800msë¡œ ì—¬ìœ  í™•ëŒ€
      isUserScrolling = true;
      console.log('ğŸ”„ User scrolling detected - auto scroll disabled');
    }

    // ğŸ”§ ìŠ¤í¬ë¡¤ ëë‚œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë”œë ˆì´ ì¦ê°€)
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => {
      updateScrollState();
    }, 250);  // 250msë¡œ ë”œë ˆì´ ì¦ê°€
  });

  // ğŸ¯ ìë™ ìŠ¤í¬ë¡¤ í•¨ìˆ˜ (margin-top ê³ ë ¤)
  function autoScrollToBottom() {
    if (!isUserScrolling) {
      lastAutoScrollTime = Date.now();  // ìë™ ìŠ¤í¬ë¡¤ ì‹œê°„ ê¸°ë¡

      // ğŸ”§ DOM ì—…ë°ì´íŠ¸ ì™„ë£Œ í›„ ìŠ¤í¬ë¡¤ ì‹¤í–‰
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {  // ì´ì¤‘ RAFë¡œ DOM ì•ˆì •í™” ëŒ€ê¸°
          // margin-topì„ ê³ ë ¤í•œ ìŠ¤í¬ë¡¤ ë†’ì´ ê³„ì‚°
          const scrollHeight = Math.max(viewer.scrollHeight, captionContainer.scrollHeight);
          viewer.scrollTo({
            top: scrollHeight,
            behavior: 'smooth'
          });
          console.log('ğŸ”½ Auto scroll triggered, scrollHeight:', scrollHeight);

          // ğŸ”§ ìŠ¤í¬ë¡¤ ì™„ë£Œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë”œë ˆì´ ì¶”ê°€)
          setTimeout(() => {
            if (!isUserScrolling) {  // ì—¬ì „íˆ ìë™ ëª¨ë“œë©´
              updateScrollState();
            }
          }, 200);  // ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ëŒ€ê¸°
        });
      });
    } else {
      console.log('â¸ï¸ Auto scroll skipped - user is scrolling');
    }
  }

  function clearViewer() {
    captionContainer.innerHTML = `
      <div class="welcome-state">
        <div class="icon">ğŸ™ï¸</div>
        <h1>ì‹¤ì‹œê°„ í•œì˜ ìë§‰</h1>
        <p>í•œêµ­ì–´ì™€ ì˜ì–´ë¡œ ë§í•˜ë©´<br>ì‹¤ì‹œê°„ ìë§‰ê³¼ ë²ˆì—­ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
        <div class="hint">
          <span>âš™ï¸</span>
          <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
        </div>
        <div style="margin-top: 16px; font-size: 14px; color: rgba(255, 255, 255, 0.5);">
          <div>ğŸ”„ ë²ˆì—­ ê·œì¹™:</div>
          <div>â€¢ í•œêµ­ì–´ â†’ ì˜ì–´</div>
          <div>â€¢ ì˜ì–´ â†’ í•œêµ­ì–´</div>
        </div>
      </div>
    `;
    currentUnstableLine = null;
    currentTypingLine = null;
    if (backToLiveBtn) {
      backToLiveBtn.style.display = 'none';
    }
  }

  function displayTranscriptAndTranslation(transcript, translation) {
    // ì›ë¬¸ í‘œì‹œ
    appendLine(transcript, 'original');

    // ë²ˆì—­ í‘œì‹œ (ì™„ì„±ëœ ê²½ìš°ë§Œ)
    if (translation &&
        !translation.includes('[ë²ˆì—­') &&
        !translation.includes('[ì˜¤ë¥˜') &&
        translation.trim().length > 0) {
      completeTypingTranslation(translation);
    }
  }

  // Permission and device handling
  async function ensurePermission() {
    try {
      logStatus('ê¶Œí•œ ìš”ì²­ ì¤‘', 'connecting');

      const permissionStatus = await navigator.permissions.query({name: 'microphone'});
      if (permissionStatus.state === 'denied') {
        throw new Error('ë§ˆì´í¬ ê¶Œí•œì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 16000  // âš¡ AudioContextì™€ ì¼ì¹˜ì‹œì¼œ ë¦¬ìƒ˜í”Œë§ ì˜¤ë²„í—¤ë“œ ì œê±°
        }
      });

      stream.getTracks().forEach(track => track.stop());
      logStatus('ê¶Œí•œ í—ˆìš©ë¨', 'connected');
      return true;
    } catch (error) {
      logStatus('ê¶Œí•œ í•„ìš”', 'error');
      showToast('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤', 'warning');
      return false;
    }
  }

  async function listMics() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      if (selMic) {
        selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';

        if (audioInputs.length === 0) {
          selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</option>';
          return;
        }

        audioInputs.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `ë§ˆì´í¬ ${index + 1}`;
          selMic.appendChild(option);
        });

        if (!currentDeviceId && audioInputs.length > 0) {
          const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
          currentDeviceId = defaultDevice.deviceId;
          selMic.value = currentDeviceId;
        }

        selMic.disabled = false;
      }
    } catch (error) {
      showToast('ì¥ì¹˜ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
    }
  }

  async function getStream(deviceId) {
    try {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      const constraints = {
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 16000,  // âš¡ AudioContextì™€ ì¼ì¹˜
          channelCount: 1
        }
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      currentDeviceId = deviceId;
      return localStream;
    } catch (error) {
      throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }

  // OpenAI Realtime API ì—°ê²° ì´ˆê¸°í™”

  // OpenAI ì„¸ì…˜ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (bootstrapì—ì„œ)
  function getOpenAISession() {
    if (!BOOT.openai_session) {
      throw new Error('OpenAI ì„¸ì…˜ì´ ì—†ìŠµë‹ˆë‹¤. ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.');
    }
    console.log('âœ… OpenAI ì„¸ì…˜ ë¡œë“œ:', BOOT.openai_session);
    return BOOT.openai_session;
  }

  async function initializeOpenAIConnection() {
    try {
      openaiSession = getOpenAISession();

      // RTCPeerConnection ì„¤ì •
      peerConnection = new RTCPeerConnection();

      // DataChannel ìƒì„± - OpenAI ë©”ì‹œì§€ìš©
      dataChannel = peerConnection.createDataChannel('oai-events', {
        ordered: true
      });

      dataChannel.onopen = () => {
        console.log('âœ… DataChannel ì—°ê²°ë¨');

        // Session instructions ì „ì†¡
        const sessionUpdate = {
          type: 'session.update',
          session: {
            input_audio_format: 'pcm16',
            input_audio_transcription: {
              model: 'gpt-4o-transcribe',
            },
            turn_detection: {
              type: 'server_vad',
              threshold: 0.5,
              prefix_padding_ms: 300,
              silence_duration_ms: 500
            }
          }
        };

        dataChannel.send(JSON.stringify(sessionUpdate));
        console.log('ğŸ“¤ Transcription-only session ì„¤ì •ë¨');
      };

      dataChannel.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleOpenAIMessage(message);
        } catch (error) {
          console.error('âŒ DataChannel ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', error);
        }
      };

      dataChannel.onerror = (error) => {
        console.error('âŒ DataChannel ì˜¤ë¥˜:', error);
      };

      dataChannel.onclose = () => {
        console.log('ğŸ”Œ DataChannel ì—°ê²° ì¢…ë£Œ');
      };

      // WebSocket ì—°ê²° (app.pyì˜ OpenAI handlerì™€ í†µì‹ ìš©)
      // ALB ê²½ë¡œ ê¸°ë°˜ ë¼ìš°íŒ… ì‚¬ìš©: /ws ê²½ë¡œë¡œ ì—°ê²°
      let hostname = window.location.hostname;

      // about:srcdoc í™˜ê²½ì—ì„œëŠ” ë¶€ëª¨ ì°½ì˜ hostname ì‚¬ìš©
      if (!hostname || hostname === '' || window.location.href.startsWith('about:')) {
        try {
          hostname = window.parent.location.hostname;
        } catch (e) {
          // Cross-origin ì œí•œì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©
          hostname = 'localhost';
        }
      }

      // í˜„ì¬ í˜ì´ì§€ í”„ë¡œí† ì½œì— ë§ì¶° WebSocket í”„ë¡œí† ì½œ ê²°ì •
      const isHTTPS = window.location.protocol === 'https:' ||
                      (window.parent && window.parent.location.protocol === 'https:');

      const wsProtocol = isHTTPS ? 'wss:' : 'ws:';

      // ALB ê²½ë¡œ ê¸°ë°˜ ë¼ìš°íŒ…: í¬íŠ¸ ì—†ì´ /ws ê²½ë¡œ ì‚¬ìš©
      const wsUrl = hostname === 'localhost'
        ? `${wsProtocol}//localhost:${BOOT.websocket_port || 8765}` // ë¡œì»¬ ê°œë°œ
        : `${wsProtocol}//${hostname}/ws`; // ë°°í¬ í™˜ê²½

      console.log(`ğŸ”— WebSocket ì—°ê²° ì‹œë„: ${wsUrl} (HTTPS: ${isHTTPS})`);

      openaiWebSocket = new WebSocket(wsUrl);

      openaiWebSocket.onopen = () => {
        console.log(`âœ… OpenAI WebSocket ì—°ê²°ë¨: ${wsUrl}`);
      };

      openaiWebSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleTranslationMessage(data);
        } catch (error) {
          console.error('âŒ WebSocket ë©”ì‹œì§€ íŒŒì‹± ì˜¤ë¥˜:', error);
        }
      };

      openaiWebSocket.onerror = (error) => {
        console.error(`âŒ OpenAI WebSocket ì˜¤ë¥˜ (${wsUrl}):`, error);
      };

      openaiWebSocket.onclose = (event) => {
        console.log(`ğŸ”Œ OpenAI WebSocket ì—°ê²° ì¢…ë£Œ (${wsUrl}): Code ${event.code}`);
      };

      return true;
    } catch (error) {
      console.error('âŒ OpenAI ì—°ê²° ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // OpenAI Realtime API ë©”ì‹œì§€ ì²˜ë¦¬
  function handleOpenAIMessage(message) {
    console.log('[OpenAI] ë©”ì‹œì§€ ìˆ˜ì‹ :', message);

    switch (message.type) {
      case 'session.created':
        console.log('âœ… OpenAI ì„¸ì…˜ ìƒì„±ë¨');
        logStatus('ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘', 'connected');
        break;

      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();
          console.log('[OpenAI Transcript]', transcript);

          // ì›ë¬¸ í‘œì‹œ (ì–¸ì–´ í‘œê¸° ì œê±°)
          appendLine(transcript, 'original');

          // WebSocketì„ í†µí•´ app.pyë¡œ ë²ˆì—­ ìš”ì²­ ì „ì†¡
          if (openaiWebSocket && openaiWebSocket.readyState === WebSocket.OPEN) {
            openaiWebSocket.send(JSON.stringify({
              type: 'transcript',
              text: transcript,
              timestamp: Date.now()
            }));
          }
        }
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('ìŒì„± ê°ì§€ë¨', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('ìŒì„± ì²˜ë¦¬ ì¤‘', 'connecting');
        break;

      case 'error':
        console.error('[OpenAI] ì˜¤ë¥˜:', message.error);
        logStatus('ì˜¤ë¥˜', 'error');
        showToast(`OpenAI ì˜¤ë¥˜: ${message.error.message || message.error}`, 'error');
        break;

      default:
        console.log('[OpenAI Unhandled]', message.type);
        break;
    }
  }

  // ë²ˆì—­ ê²°ê³¼ ì²˜ë¦¬ (app.py WebSocketì—ì„œ)
  function handleTranslationMessage(data) {
    console.log('[Translation] ë©”ì‹œì§€ ìˆ˜ì‹ :', data);

    switch (data.type) {
      case 'transcription_result':
        // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ í‘œì‹œ
        if (data.translated_text && data.translated_text !== data.original_text) {
          startTypingTranslation();
          // ì¦‰ì‹œ ë²ˆì—­ ì™„ë£Œ í‘œì‹œ
          setTimeout(() => {
            completeTypingTranslation(data.translated_text);
          }, 100);
        }
        break;

      case 'connection':
        console.log('[Translation] ì—°ê²° ìƒíƒœ:', data.status);
        break;

      case 'error':
        console.error('[Translation] ì˜¤ë¥˜:', data.message);
        showToast(`ë²ˆì—­ ì˜¤ë¥˜: ${data.message}`, 'error');
        if (currentTypingLine) {
          currentTypingLine.remove();
          currentTypingLine = null;
        }
        break;

      default:
        console.log('[Translation] ì•Œ ìˆ˜ ì—†ëŠ” ë©”ì‹œì§€ íƒ€ì…:', data.type);
        break;
    }
  }

  // OpenAI Realtime API ì—°ê²° (WebRTC)
  async function connectOpenAIRealtime() {
    try {
      logStatus('ì—°ê²° ì¤‘', 'connecting');
      startTime = Date.now();

      await initializeOpenAIConnection();

      if (!localStream && currentDeviceId) {
        localStream = await getStream(currentDeviceId);
      } else if (!localStream) {
        throw new Error('ë§ˆì´í¬ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }

      // ì˜¤ë””ì˜¤ íŠ¸ë™ì„ RTCPeerConnectionì— ì¶”ê°€
      localStream.getAudioTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // SDP Offer ìƒì„±
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      console.log('ğŸ“¤ SDP Offer ìƒì„±ë¨');

      // OpenAI Realtime APIì— ì—°ê²° ìš”ì²­
      const response = await fetch(`https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiSession.client_secret}`,
          'Content-Type': 'application/sdp'
        },
        body: offer.sdp
      });

      if (!response.ok) {
        throw new Error(`OpenAI API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
      }

      const answerSdp = await response.text();
      console.log('ğŸ“¥ SDP Answer ìˆ˜ì‹ ë¨');

      const answer = {
        type: 'answer',
        sdp: answerSdp
      };

      await peerConnection.setRemoteDescription(answer);
      console.log('âœ… OpenAI WebRTC ì—°ê²° ì™„ë£Œ');

      logStatus('ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘', 'connected');

    } catch (error) {
      console.error('âŒ OpenAI ì—°ê²° ì‹¤íŒ¨:', error);
      logStatus('ì—°ê²° ì‹¤íŒ¨', 'error');
      showToast(error.message || 'OpenAI ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
      closeConnection();
      throw error;
    }
  }

  // AWS ì„œë²„ ì—°ê²° (ë ˆê±°ì‹œ - ì‚¬ìš© ì•ˆí•¨)
  function initializeAWSConnection() {

    if (!BOOT.aws_session) {
      const error = 'BOOT.aws_sessionì´ ì—†ìŠµë‹ˆë‹¤.';
      console.error('âŒ', error);
      throw new Error(error);
    }

    let wsUrl = BOOT.aws_session.websocket_url;

    if (!wsUrl) {
      const region = BOOT.aws_session.region || 'us-east-1';
      wsUrl = `wss://transcribestreaming.${region}.amazonaws.com:8443/stream-transcription-websocket`;
      console.log('âš ï¸ websocket_urlì´ ì—†ì–´ì„œ ê¸°ë³¸ URL ìƒì„±:', wsUrl);
    }

    return new Promise((resolve, reject) => {
      console.log('ğŸ”— WebSocket ì—°ê²° ì‹œë„:', wsUrl);

      try {
        awsWebSocket = new WebSocket(wsUrl);

        // ğŸ” ì—°ê²° ìƒíƒœ ìƒì„¸ ëª¨ë‹ˆí„°ë§
        let messageCount = 0;
        let lastHeartbeat = Date.now();

        const connectionTimeout = setTimeout(() => {
          if (awsWebSocket.readyState === WebSocket.CONNECTING) {
            console.error('âŒ WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ');
            awsWebSocket.close();
            reject(new Error('WebSocket ì—°ê²° íƒ€ì„ì•„ì›ƒ'));
          }
        }, 10000);

        awsWebSocket.onopen = () => {
          clearTimeout(connectionTimeout);
          console.log('âœ… [AWS WebSocket] ì—°ê²° ì„±ê³µ');


          resolve(true);
        };

        awsWebSocket.onmessage = (event) => {
          messageCount++;
          lastHeartbeat = Date.now();

          try {
            const data = JSON.parse(event.data);
            handleAWSMessage(data);
          } catch (error) {
            console.error('âŒ [AWS WebSocket] JSON íŒŒì‹± ì˜¤ë¥˜:', error);
          }
        };

        awsWebSocket.onerror = (error) => {
          clearTimeout(connectionTimeout);
          console.error('âŒ [AWS WebSocket] ì˜¤ë¥˜:', error);
          reject(error);
        };

        awsWebSocket.onclose = (event) => {
          clearTimeout(connectionTimeout);
          console.log('ğŸ”Œ [AWS WebSocket] ì—°ê²° ì¢…ë£Œ');
          awsWebSocket = null;
        };

      } catch (error) {
        console.error('âŒ WebSocket ìƒì„± ì˜¤ë¥˜:', error);
        reject(error);
      }
    });
  }

  // AWS ë©”ì‹œì§€ ì²˜ë¦¬
  function handleAWSMessage(data) {
    console.log('[AWS] ë©”ì‹œì§€ ìˆ˜ì‹ :', data);

    switch (data.type) {
      case 'connection':
        logStatus('AWS ì—°ê²°ë¨ (ë‹¤ì¤‘ì–¸ì–´+LLM)', 'connected');
        break;

      case 'transcription_partial':
        // ì‹¤ì‹œê°„ transcription (ë¶€ë¶„)
        if (!currentUnstableLine) {
          appendLine(`[ì¸ì‹ì¤‘] ${data.transcript}`, 'unstable');
        } else {
          currentUnstableLine.textContent = `[ì¸ì‹ì¤‘] ${data.transcript}`;
        }
        break;

      case 'transcription_result':
        // ìƒˆë¡œìš´ ë‹¤ì¤‘ì–¸ì–´ + ë²ˆì—­ ê²°ê³¼ ì²˜ë¦¬
        if (currentUnstableLine) {
          currentUnstableLine.remove();
          currentUnstableLine = null;
        }

        // ì›ë³¸ í…ìŠ¤íŠ¸ í‘œì‹œ (ì–¸ì–´ ì •ë³´ í¬í•¨)
        const sourceLanguageName = getLanguageName(data.source_language);
        appendLine(`${data.original_text} (${sourceLanguageName})`, 'original');

        // ë²ˆì—­ëœ í…ìŠ¤íŠ¸ê°€ ìˆë‹¤ë©´ íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜ìœ¼ë¡œ í‘œì‹œ
        if (data.translated_text && data.translated_text !== data.original_text) {
          const targetLanguageName = getLanguageName(data.target_language);
          startTypingTranslation();
          // âš¡ ì• ë‹ˆë©”ì´ì…˜ ë”œë ˆì´ ì œê±° - ì¦‰ì‹œ í‘œì‹œ
          completeTypingTranslation(`${data.translated_text}`);
        }
        break;

      case 'translation_result':
        // ì§ì ‘ ë²ˆì—­ ìš”ì²­ ê²°ê³¼ (ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€)
        if (data.translated_text) {
          startTypingTranslation();
          // âš¡ ì• ë‹ˆë©”ì´ì…˜ ë”œë ˆì´ ì œê±° - ì¦‰ì‹œ í‘œì‹œ
          completeTypingTranslation(data.translated_text);
        }
        break;

      case 'error':
        console.error('[AWS] ì˜¤ë¥˜:', data.message);
        showToast(`AWS ì˜¤ë¥˜: ${data.message}`, 'error');
        appendLine(`âŒ ì˜¤ë¥˜: ${data.message}`, 'original');
        break;
    }
  }

  // ì–¸ì–´ ì½”ë“œë¥¼ í•œêµ­ì–´ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
  function getLanguageName(languageCode) {
    const languageNames = {
      'en-US': 'ì˜ì–´',
      'en': 'ì˜ì–´',
      'ko-KR': 'í•œêµ­ì–´',
      'ko': 'í•œêµ­ì–´',
      'zh-CN': 'ì¤‘êµ­ì–´',
      'zh': 'ì¤‘êµ­ì–´',
      'ja-JP': 'ì¼ë³¸ì–´',
      'ja': 'ì¼ë³¸ì–´',
      'es': 'ìŠ¤í˜ì¸ì–´',
      'fr': 'í”„ë‘ìŠ¤ì–´',
      'de': 'ë…ì¼ì–´'
    };
    return languageNames[languageCode] || languageCode;
  }


  // AWS Transcribe ì§ì ‘ ì—°ê²° (ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë°)
  let audioContext = null;
  let audioWorklet = null;
  let mediaStream = null;
  let isTranscriptionActive = false;


  async function connectAWSTranscribe() {
    try {
      logStatus('ì—°ê²° ì¤‘', 'connecting');
      startTime = Date.now();

      await initializeAWSConnection();
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 16000
        });
      }

      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }

      if (!mediaStream && currentDeviceId) {
        mediaStream = await getStream(currentDeviceId);
      } else if (!mediaStream) {
        throw new Error('ë§ˆì´í¬ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      }

      // ğŸ” ë””ë²„ê¹…ì´ ê°•í™”ëœ AudioWorkletProcessor
      const audioWorkletCode = `
        class AudioProcessor extends AudioWorkletProcessor {
          constructor() {
            super();
            this.bufferSize = 1024;  // âš¡ ë” ì‘ì€ ë²„í¼ë¡œ ì§€ì—°ì‹œê°„ ë‹¨ì¶• (64ms)
            this.buffer = new Float32Array(this.bufferSize);
            this.bufferIndex = 0;
            this.chunkCount = 0;
            this.lastLogTime = 0;
            this.totalSamples = 0;
            this.maxVolume = 0;
          }

          process(inputs) {
            const input = inputs[0];
            if (input.length > 0 && input[0]) {
              const audioData = input[0];
              this.totalSamples += audioData.length;

              // ë³¼ë¥¨ ì²´í¬
              let chunkMax = 0;
              for (let i = 0; i < audioData.length; i++) {
                const sample = Math.abs(audioData[i]);
                if (sample > chunkMax) chunkMax = sample;
                if (sample > this.maxVolume) this.maxVolume = sample;

                this.buffer[this.bufferIndex] = audioData[i];
                this.bufferIndex++;

                if (this.bufferIndex >= this.bufferSize) {
                  this.chunkCount++;

                  // PCM ë³€í™˜
                  const pcmBuffer = new ArrayBuffer(this.bufferSize * 2);
                  const pcmView = new DataView(pcmBuffer);

                  for (let j = 0; j < this.bufferSize; j++) {
                    const sample = Math.max(-1, Math.min(1, this.buffer[j]));
                    const pcmSample = Math.round(sample * 32767);
                    pcmView.setInt16(j * 2, pcmSample, true);
                  }

                  this.port.postMessage({
                    type: 'audio',
                    data: pcmBuffer,
                    chunkId: this.chunkCount,
                    maxVolume: chunkMax,
                    sampleRate: 16000,
                    channels: 1
                  });

                  this.bufferIndex = 0;
                }
              }

            }
            return true;
          }
        }
        registerProcessor('audio-processor', AudioProcessor);
      `;

      const blob = new Blob([audioWorkletCode], { type: 'application/javascript' });
      const workletUrl = URL.createObjectURL(blob);
      await audioContext.audioWorklet.addModule(workletUrl);

      audioWorklet = new AudioWorkletNode(audioContext, 'audio-processor');

      audioWorklet.port.onmessage = (event) => {
        if (event.data.type === 'audio') {
          const now = Date.now();
          const { data: audioBuffer, chunkId, maxVolume } = event.data;
          const dataSize = audioBuffer.byteLength;

          // ìŒì„± ê°ì§€ (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
          const isSpeech = maxVolume > 0.05;

          if (!window.speechState) {
            window.speechState = {
              isDetected: false,
              lastDetectionTime: 0,
              consecutiveSpeech: 0,
              lastDisplayTime: 0
            };
          }

          if (isSpeech) {
            window.speechState.consecutiveSpeech++;

            if (!window.speechState.isDetected) {
              window.speechState.isDetected = true;
            }

            window.speechState.lastDetectionTime = now;
          } else {
            if (window.speechState.isDetected && (now - window.speechState.lastDetectionTime > 3000)) {
              window.speechState.isDetected = false;
              window.speechState.consecutiveSpeech = 0;
            }
          }

          // AWSë¡œ ë°ì´í„° ì „ì†¡
          if (awsWebSocket && awsWebSocket.readyState === WebSocket.OPEN && isTranscriptionActive) {
            try {
              // âš¡ ë” íš¨ìœ¨ì ì¸ Base64 ì¸ì½”ë”© ë°©ì‹
              const uint8Array = new Uint8Array(audioBuffer);
              let binary = '';
              const chunkSize = 8192; // 8KB ì²­í¬ë¡œ ì²˜ë¦¬í•˜ì—¬ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
              for (let i = 0; i < uint8Array.length; i += chunkSize) {
                const chunk = uint8Array.subarray(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
              }
              const base64Audio = btoa(binary);

              const message = {
                type: 'audio_chunk',
                audio: base64Audio,
                format: 'pcm',
                sample_rate: 16000,
                channels: 1,
                bytes_per_sample: 2,
                timestamp: now,
                chunk_id: chunkId,
                data_size: dataSize,
                max_volume: maxVolume
              };

              awsWebSocket.send(JSON.stringify(message));

            } catch (error) {
              console.error('âŒ [WebSocket] ì „ì†¡ ì˜¤ë¥˜:', error);
            }
        }
        }
      };

      const source = audioContext.createMediaStreamSource(mediaStream);
      source.connect(audioWorklet);

      isTranscriptionActive = true;
      logStatus('ğŸ¤ ìŒì„± ì¸ì‹ ì¤‘', 'connected');

    } catch (error) {
      console.error('âŒ ì—°ê²° ì‹¤íŒ¨:', error);
      logStatus('ì—°ê²° ì‹¤íŒ¨', 'error');
      showToast(error.message || 'ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
      closeConnection();
      throw error;
    }
  }


  // ë²ˆì—­ ìš”ì²­ ìŠ¤ë§ˆíŠ¸ í•„í„°ë§ í•¨ìˆ˜
  function shouldRequestTranslation(transcript) {
    const now = Date.now();

    // 1. ì´ë¯¸ ë²ˆì—­ ì§„í–‰ ì¤‘ì´ë©´ ìŠ¤í‚µ
    if (responseInProgress) {
      console.log('[Skip Translation] Already in progress');
      return false;
    }

    // 2. ê°™ì€ ë‚´ìš© ë˜ëŠ” ë§¤ìš° ìœ ì‚¬í•œ ë‚´ìš©ì´ë©´ ìŠ¤í‚µ
    if (lastTranslationRequest === transcript) {
      console.log('[Skip Translation] Duplicate request');
      return false;
    }

    // 3. ì´ì „ ìš”ì²­ì´ ë¶€ë¶„ ë¬¸ìì—´ì¸ê²½ìš° ìŠ¤í‚µ (í™•ì¥ëœ ë‚´ìš©)
    if (lastTranslationRequest && transcript.startsWith(lastTranslationRequest) &&
        transcript.length - lastTranslationRequest.length < 10) {
      console.log('[Skip Translation] Minor extension of previous request');
      return false;
    }

    // 4. ë„ˆë¬´ ë¹ ë¥¸ ì—°ì† ìš”ì²­ ë°©ì§€ (ë””ë°”ìš´ì‹±)
    if (now - translationRequestTime < 1000) { // 1ì´ˆ ê°„ê²©
      console.log('[Skip Translation] Too frequent requests');
      return false;
    }

    return true;
  }

  // ì˜ì–´ ë¬¸ì¥ ì™„ì„±ë„ ì²´í¬ í•¨ìˆ˜ ì¶”ê°€
  function isTranscriptComplete(transcript) {
    // ìµœì†Œ ê¸¸ì´ ì²´í¬ (ì˜ì–´ëŠ” 3ê¸€ì ì´ìƒ)
    if (transcript.length < 3) {
      return false;
    }

    // ë¬¸ì¥ ë¶€í˜¸ë¡œ ëë‚˜ë©´ ì™„ì„±ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼
    if (/[.!?]$/.test(transcript)) {
      return true;
    }

    // ë‹¨ì–´ê°€ ì™„ì „íˆ ëë‚¬ëŠ”ì§€ ì²´í¬ (ê³µë°±ì´ë‚˜ êµ¬ë‘ì  ë’¤ ì™„ì „í•œ ë‹¨ì–´)
    const words = transcript.split(/\s+/);
    const lastWord = words[words.length - 1];

    // ë§ˆì§€ë§‰ ë‹¨ì–´ê°€ ë„ˆë¬´ ì§§ìœ¼ë©´ ë¶ˆì™„ì „í•  ê°€ëŠ¥ì„±
    if (lastWord.length < 2) {
      return false;
    }

    // ì¼ë°˜ì ì¸ ë¶ˆì™„ì „ ë‹¨ì–´ íŒ¨í„´ë“¤
    const incompletePatterns = [
      /ing$/,  // -ingë¡œ ëë‚˜ëŠ” ê²½ìš°ëŠ” ëŒ€ë¶€ë¶„ ì™„ì„±
      /ed$/,   // -edë¡œ ëë‚˜ëŠ” ê²½ìš°ë„ ì™„ì„±
      /[aeiou]$/,  // ëª¨ìŒìœ¼ë¡œ ëë‚˜ë©´ ë³´í†µ ì™„ì„±
      /[bcdfghjklmnpqrstvwxyz]{2,}$/  // ììŒ 2ê°œ ì´ìƒìœ¼ë¡œ ëë‚˜ë©´ ë³´í†µ ì™„ì„±
    ];

    // íŒ¨í„´ ë§¤ì¹­ìœ¼ë¡œ ì™„ì„±ë„ íŒë‹¨
    return incompletePatterns.some(pattern => pattern.test(lastWord.toLowerCase()));
  }

  function handleRealtimeMessage(message) {
    if (isPaused && !message.type?.includes('error')) {
      return;
    }


    // ì§€ì—°ì‹œê°„ ì¸¡ì •
    if (startTime && latencyEl && !latencyEl.textContent) {
      const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
        (message.delta || message.text || message.transcript);
      if (isContent) {
        const latency = Date.now() - startTime;
        logLatency(latency);
        startTime = null;
      }
    }

    switch (message.type) {
      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();

          // ì˜ì–´ ë¬¸ì¥ ì™„ì„±ë„ ì²´í¬ ê°œì„ 
          const isComplete = isTranscriptComplete(transcript);
          const isDuplicate = transcript === lastProcessedTranscript ||
                            (lastProcessedTranscript && transcript.length > 5 &&
                             lastProcessedTranscript.includes(transcript.slice(0, -2)));

          if (!isComplete || isDuplicate) {
            console.log('[Skip] Incomplete or duplicate:', transcript, { isComplete, isDuplicate });
            break;
          }

          lastProcessedTranscript = transcript;
          console.log('[Transcription] New:', transcript);

          // ì´ì „ pending ì™„ë£Œ
          if (pendingTranscript && pendingTranscript !== transcript) {
            if (pendingTranslation) {
              completeTypingTranslation(pendingTranslation);
            } else if (currentTypingLine) {
              currentTypingLine.remove();
              currentTypingLine = null;
            }
          }

          // ğŸ¨ ì›ë¬¸ ì¦‰ì‹œ í‘œì‹œ
          appendLine(transcript, 'original');

          // ğŸ¨ ë¹ˆ íƒ€ì´í•‘ ë§í’ì„  ìƒì„±
          startTypingTranslation();

          pendingTranscript = transcript;
          pendingTranslation = '';

          // ğŸš€ ìŠ¤ë§ˆíŠ¸ í•„í„°ë§ìœ¼ë¡œ ë¶ˆí•„ìš”í•œ ë²ˆì—­ ìš”ì²­ ë°©ì§€
          if (dc && dc.readyState === 'open' && shouldRequestTranslation(transcript)) {
            responseInProgress = true;
            lastTranslationRequest = transcript;
            translationRequestTime = Date.now();

            dc.send(JSON.stringify({ type: 'response.create' }));
            console.log('[Translation] âœ… Requested for:', transcript);

            setTimeout(() => {
              if (responseInProgress && pendingTranscript === transcript) {
                console.warn('[Translation] â±ï¸ Timeout for:', transcript);
                responseInProgress = false;
                currentResponseId = null;
                if (currentTypingLine) {
                  currentTypingLine.remove();
                  currentTypingLine = null;
                }
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }, 2500);
          } else if (dc && dc.readyState === 'open') {
            // ë²ˆì—­ ìš”ì²­ì„ ìŠ¤í‚µí–ˆì§€ë§Œ ì›ë¬¸ì€ í‘œì‹œí–ˆìœ¼ë¯€ë¡œ ìƒíƒœ ì •ë¦¬
            console.log('[Translation] ğŸš« Skipped request for:', transcript);
            pendingTranscript = null;
            pendingTranslation = '';
          }
        }
        break;

      case 'response.text.delta':
        if (message.delta && pendingTranscript) {
          const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
          if (!cleanDelta.toLowerCase().includes('cannot') &&
              !cleanDelta.toLowerCase().includes('sorry')) {
            pendingTranslation += cleanDelta;

            // ğŸ¨ ì‹¤ì‹œê°„ íƒ€ì´í•‘ ì—…ë°ì´íŠ¸
            updateTypingTranslation(pendingTranslation);
            console.log('[Delta]', cleanDelta);
          }
        }
        break;

      case 'response.text.done':
        if (message.text && pendingTranscript) {
          let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
          console.log('[Done]', cleanText);

          // ğŸš« ê±°ë¶€ ë©”ì‹œì§€ë“¤ í•„í„°ë§ ê°•í™”
          if (cleanText.toLowerCase().includes('cannot assist') ||
              cleanText.toLowerCase().includes('sorry, but i can\'t') ||
              cleanText.toLowerCase().includes('ì£„ì†¡í•©ë‹ˆë‹¤') ||
              cleanText.toLowerCase().includes('ì‘ë‹µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤') ||
              cleanText.toLowerCase().includes('í•´ë‹¹ ìš”ì²­') ||
              cleanText.length === 0) {
            cleanText = '';
          }

          const finalTranslation = cleanText || pendingTranslation.trim();
          console.log('[Final Translation]', finalTranslation);

          if (finalTranslation && finalTranslation.length > 0) {
            // ğŸ¨ íƒ€ì´í•‘ ì™„ë£Œ - ì´ˆë¡ìƒ‰ í…Œë‘ë¦¬ë¡œ ë³€ê²½
            completeTypingTranslation(finalTranslation);
          } else if (currentTypingLine) {
            // ë²ˆì—­ ì‹¤íŒ¨ ì‹œ íƒ€ì´í•‘ ë¼ì¸ ì œê±°
            currentTypingLine.remove();
            currentTypingLine = null;
          }

          pendingTranscript = null;
          pendingTranslation = '';
        }
        break;

      case 'response.created':
        currentResponseId = message.response?.id || Date.now().toString();
        responseInProgress = true;
        console.log('[Response] Created:', currentResponseId);
        break;

      case 'response.done':
        responseInProgress = false;
        currentResponseId = null;
        console.log('[Response] Done');
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('ìŒì„± ì¸ì‹ ì¤‘', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('ì²˜ë¦¬ ì¤‘', 'connecting');
        break;

      case 'error':
        console.error('[Error]', message.error);
        logStatus('ì˜¤ë¥˜', 'error');
        showToast('ì„œë¹„ìŠ¤ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
        break;

      default:
        console.log('[Unhandled]', message.type);
        break;
    }
  }

  function closeConnection() {
    try {
      // AWS WebSocket ì—°ê²° í•´ì œ
      if (awsWebSocket) {
        awsWebSocket.close();
        awsWebSocket = null;
      }

      // ìŒì„± ì¸ì‹ ì¤‘ë‹¨
      stopSpeechRecognition();

      // ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      // ìƒíƒœ ì´ˆê¸°í™”
      currentUnstableLine = null;
      currentTypingLine = null;
      responseInProgress = false;
      currentResponseId = null;
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      lastTranslationRequest = null;
      translationRequestTime = 0;
      isPaused = false;
      isUserScrolling = false;
      lastAutoScrollTime = 0;

      logStatus('ëŒ€ê¸°ì¤‘', '');
      logLatency(0);
      if (backToLiveBtn) {
        backToLiveBtn.style.display = 'none';
      }

      console.log('[AWS] Connection closed and resources cleaned up');
    } catch (error) {
      console.error('Close connection error:', error);
    }
  }

  // Event handlers
  if (btnPerm) {
    btnPerm.onclick = async () => {
      const success = await ensurePermission();
      if (success) {
        await listMics();
      }
    };
  }

  // ğŸš« ì¼ì‹œì •ì§€ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
  // if (btnPause) { ... } â† ì‚­ì œ

  if (selMic) {
    selMic.onchange = async (event) => {
      const newDeviceId = event.target.value;
      if (!newDeviceId) return;

      const wasConnected = peerConnection && peerConnection.connectionState === 'connected';
      currentDeviceId = newDeviceId;

      if (wasConnected) {
        try {
          logStatus('ì¥ì¹˜ ë³€ê²½ ì¤‘', 'connecting');
          closeConnection();

          // ìƒˆ ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„
          const newStream = await getStream(newDeviceId);

          // OpenAI ì—°ê²° ì¬ì‹œì‘
          setTimeout(async () => {
            try {
              await connectOpenAIRealtime();
            logStatus('ì—°ê²°ë¨', 'connected');
            } catch (error) {
              logStatus('ì¥ì¹˜ ë³€ê²½ ì‹¤íŒ¨', 'error');
              selMic.value = currentDeviceId;
          }
          }, 1000);

        } catch (error) {
          logStatus('ì¥ì¹˜ ë³€ê²½ ì‹¤íŒ¨', 'error');
          selMic.value = currentDeviceId;
        }
      }
    };
  }


  (async () => {
    try {
      console.log('Bootstrap starting...', BOOT);

      if (BOOT.action === 'start' && BOOT.openai_session) {
        const hasPermission = await ensurePermission();
        if (hasPermission) {
          await listMics();
          await connectOpenAIRealtime();
        }
      } else if (BOOT.action === 'stop') {
        closeConnection();
        clearViewer();
      } else {
        logStatus('ëŒ€ê¸°ì¤‘', '');
      }

      console.log('Bootstrap completed successfully');
    } catch (error) {
      console.error('Bootstrap error:', error);
      logStatus('ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
      showToast(`ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}`, 'error');
    }
  })();

  // Cleanup
  window.addEventListener('beforeunload', () => {
    closeConnection();
  });

} catch (globalError) {
  console.error('Global script error:', globalError);
  document.getElementById('status').textContent = 'ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜';
  document.getElementById('status').className = 'status-chip error';
}
</script>
</body>
</html>
