<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
    }

    /* ğŸ¨ ë™ì  í°íŠ¸ í¬ê¸° CSS ë³€ìˆ˜ */
    :root {
      --translation-font-size: 28px;
      --original-font-size: 16px;
    }

    /* í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ */
    .settings-fab {
      position: fixed;
      top: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* ì„¤ì • íŒ¨ë„ */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* ğŸ¨ ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ë§ */
    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      margin: 8px 0 12px 0;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #059669;
      transform: scale(1.2);
    }

    .control-group span {
      display: inline-block;
      min-width: 60px;
      color: #10b981;
      font-weight: 500;
      font-size: 13px;
    }

    /* ìƒíƒœ í‘œì‹œ */
    .status-overlay {
      position: fixed;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ */
    .back-to-live {
      position: fixed;
      bottom: 32px;
      right: 32px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
    }

    /* ğŸ¯ ë©”ì¸ ìº¡ì…˜ ë·°ì–´ - ìŠ¤í¬ë¡¤ë°” ì™„ì „ ìˆ¨ê¹€ */
    #viewer {
      height: 100vh;
      width: 100%;
      padding: 0;
      overflow-y: auto;
      background: transparent;
      scroll-behavior: smooth;
      display: flex;
      align-items: center;
      justify-content: center;
      scrollbar-width: none;        /* Firefox */
      -ms-overflow-style: none;     /* IE and Edge */
    }

    #viewer::-webkit-scrollbar {
      display: none;                /* Chrome, Safari */
    }

    /* ìë§‰ ì»¨í…Œì´ë„ˆ */
    .caption-container {
      width: 100%;
      max-width: 1200px;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0;
      padding-bottom: 100px;
    }

    .caption-line {
      margin-bottom: 24px;
      line-height: 1.5;
      padding: 20px 32px;
      border-radius: 16px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    /* ì›ë¬¸ ìŠ¤íƒ€ì¼ */
    .caption-line.original {
      font-size: var(--original-font-size);
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 12px;
      font-weight: 300;
      max-width: 85%;
    }

    /* ë²ˆì—­ëœ ìë§‰ ìŠ¤íƒ€ì¼ */
    .caption-line.stable {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* ğŸ¨ íƒ€ì´í•‘ ì¤‘ì¸ ë²ˆì—­ ë§í’ì„  */
    .caption-line.typing {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #fbbf24;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
      animation: typing-breathe 1.5s ease-in-out infinite;
      position: relative;
    }

    /* íƒ€ì´í•‘ ì»¤ì„œ íš¨ê³¼ */
    .caption-line.typing::after {
      content: '|';
      color: #fbbf24;
      animation: cursor-blink 1s ease-in-out infinite;
      margin-left: 2px;
    }

    @keyframes typing-breathe {
      0%, 100% {
        border-left-color: #fbbf24;
      }
      50% {
        border-left-color: #f59e0b;
        box-shadow: 0 8px 32px rgba(251, 191, 36, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* ì‹¤ì‹œê°„ ì…ë ¥ ì¤‘ */
    .caption-line.unstable {
      font-size: calc(var(--translation-font-size) - 2px);
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    /* ğŸ¨ ë§í’ì„  ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ */
    .caption-line.fade-in {
      animation: fadeInUp 0.4s ease-out forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* ë¹ˆ ìƒíƒœ */
    .welcome-state {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* ë°˜ì‘í˜• ë””ìì¸ */
    @media (max-width: 768px) {
      .settings-panel {
        width: 100%;
      }

      .caption-container {
        padding: 20px;
      }

      .caption-line.stable, .caption-line.typing {
        font-size: calc(var(--translation-font-size) * 0.8);
        padding: 16px 20px;
        max-width: 95%;
      }

      .caption-line.original {
        font-size: calc(var(--original-font-size) * 0.9);
        padding: 12px 16px;
      }
    }
  </style>
</head>

<body>
  <!-- í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ -->
  <button class="settings-fab" id="settingsFab">âš™ï¸</button>

  <!-- ì„¤ì • íŒ¨ë„ -->
  <div class="settings-panel" id="settingsPanel">
    <h2>ì‹¤ì‹œê°„ ìë§‰ ì„¤ì •</h2>

    <div class="control-group">
      <label>ë§ˆì´í¬ ê¶Œí•œ</label>
      <button id="btnPerm">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
    </div>

    <div class="control-group">
      <label>ì˜¤ë””ì˜¤ ì¥ì¹˜</label>
      <select id="selMic" disabled>
        <option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
      </select>
    </div>

    <!-- ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ -->
    <div class="control-group">
      <label>ğŸ“ ë²ˆì—­ ê¸€ì í¬ê¸°</label>
      <input type="range" id="fontSizeSlider" min="18" max="48" value="28" step="2" class="slider">
      <span id="fontSizeValue">28px</span>
    </div>

    <div class="control-group">
      <label>ğŸ“„ ì›ë¬¸ ê¸€ì í¬ê¸°</label>
      <input type="range" id="originalSizeSlider" min="12" max="24" value="16" step="1" class="slider">
      <span id="originalSizeValue">16px</span>
    </div>

    <div class="control-group">
      <label>ì œì–´</label>
      <button id="btnPause" style="display: none;">â¸ï¸ ì¼ì‹œì •ì§€</button>
      <button id="btnClear">ğŸ—‘ï¸ ìë§‰ ì§€ìš°ê¸°</button>
    </div>
  </div>

  <!-- ìƒíƒœ í‘œì‹œ -->
  <div class="status-overlay">
    <div id="status" class="status-chip">ëŒ€ê¸°ì¤‘</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ -->
  <button class="back-to-live" id="backToLive">
    ğŸ“º ì‹¤ì‹œê°„ìœ¼ë¡œ
    <span style="margin-left: 4px;">â¬‡ï¸</span>
  </button>

  <!-- ë©”ì¸ ìº¡ì…˜ ë·°ì–´ -->
  <div id="viewer">
    <div class="caption-container" id="captionContainer">
      <div class="welcome-state">
        <div class="icon">ğŸ™ï¸</div>
        <h1>ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ìë§‰</h1>
        <p>ì˜ì–´ë¡œ ë§í•˜ë©´ í•œêµ­ì–´ ìë§‰ì´<br>ì‹¤ì‹œê°„ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
        <div class="hint">
          <span>âš™ï¸</span>
          <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
        </div>
      </div>
    </div>
  </div>

<script>
try {
  // Bootstrap data
  const BOOT = {{BOOTSTRAP_JSON}};
  console.log('BOOT data:', BOOT);

  // Global state
  let pc = null;
  let dc = null;
  let localStream = null;
  let currentDeviceId = null;
  let startTime = null;
  let currentUnstableLine = null;
  let currentTypingLine = null;  // ğŸ¨ íƒ€ì´í•‘ ë¼ì¸
  let responseInProgress = false;
  let currentResponseId = null;
  let pendingTranscript = null;
  let pendingTranslation = '';
  let lastProcessedTranscript = null;
  let isPaused = false;
  let isUserScrolling = false;    // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ìƒíƒœ
  let lastAutoScrollTime = 0;     // ğŸ¯ ë§ˆì§€ë§‰ ìë™ ìŠ¤í¬ë¡¤ ì‹œê°„

  // DOM elements with null checks
  const viewer = document.getElementById('viewer');
  const captionContainer = document.getElementById('captionContainer');
  const selMic = document.getElementById('selMic');
  const statusEl = document.getElementById('status');
  const latencyEl = document.getElementById('latency');
  const btnPerm = document.getElementById('btnPerm');
  const btnPause = document.getElementById('btnPause');
  const btnClear = document.getElementById('btnClear');
  const settingsFab = document.getElementById('settingsFab');
  const settingsPanel = document.getElementById('settingsPanel');
  const backToLiveBtn = document.getElementById('backToLive');
  const fontSizeSlider = document.getElementById('fontSizeSlider');
  const fontSizeValue = document.getElementById('fontSizeValue');
  const originalSizeSlider = document.getElementById('originalSizeSlider');
  const originalSizeValue = document.getElementById('originalSizeValue');

  // Null check for critical elements
  if (!viewer || !captionContainer || !statusEl) {
    throw new Error('í•„ìˆ˜ DOM ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  }

  // ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (null check í¬í•¨)
  if (fontSizeSlider && fontSizeValue) {
    fontSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--translation-font-size', `${size}px`);
      fontSizeValue.textContent = `${size}px`;
    };
  }

  if (originalSizeSlider && originalSizeValue) {
    originalSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--original-font-size', `${size}px`);
      originalSizeValue.textContent = `${size}px`;
    };
  }

  // ì„¤ì • íŒ¨ë„ í† ê¸€
  if (settingsFab && settingsPanel) {
    settingsFab.onclick = () => {
      settingsPanel.classList.toggle('open');
      settingsFab.classList.toggle('active');
    };
  }

  // ì„¤ì • íŒ¨ë„ ì™¸ë¶€ í´ë¦­ì‹œ ë‹«ê¸°
  document.addEventListener('click', (e) => {
    if (settingsPanel && settingsFab &&
        !settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
      settingsPanel.classList.remove('open');
      settingsFab.classList.remove('active');
    }
  });

  // ğŸ”„ ëŒ€í™” ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” í•¨ìˆ˜ ì¶”ê°€
  function resetConversationContext() {
    if (dc && dc.readyState === 'open') {
      // ğŸš« conversation.item.truncate ëŒ€ì‹  ì„¸ì…˜ ì¬ì„¤ì •ìœ¼ë¡œ ì»¨í…ìŠ¤íŠ¸ í´ë¦¬ì–´
      const sessionUpdate = {
        type: 'session.update',
        session: {
          instructions: getTranslationInstructions(),
          input_audio_transcription: {
            model: 'whisper-1',
            language: 'en'
          },
          turn_detection: {
            type: 'server_vad',
            threshold: 0.5,
            prefix_padding_ms: 200,
            silence_duration_ms: 400,
            create_response: false
          },
          modalities: ['text'],
          temperature: 0.6,
          max_response_output_tokens: 500
        }
      };

      dc.send(JSON.stringify({
        type: 'conversation.item.truncate',
        conversation_id: 'main',
        content_index: 0
      }));

      console.log('[Context] ì„¸ì…˜ ì¬ì„¤ì •ìœ¼ë¡œ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');

      // ğŸ”„ ì¶”ê°€ì ìœ¼ë¡œ ìƒˆë¡œìš´ ëŒ€í™” ì‹œì‘ì„ ìœ„í•œ ë”ë¯¸ ë©”ì‹œì§€ (ì„ íƒì )
      // ì´ê²ƒì€ AIê°€ ì™„ì „íˆ ìƒˆë¡œìš´ ëŒ€í™”ë¡œ ì¸ì‹í•˜ê²Œ ë„ì™€ì¤ë‹ˆë‹¤
      setTimeout(() => {
        if (dc && dc.readyState === 'open') {
          // ë¹ˆ ì‘ë‹µìœ¼ë¡œ ëŒ€í™” ìƒíƒœ ë¦¬ì…‹
          dc.send(JSON.stringify({
            type: 'input_audio_buffer.clear'
          }));
          console.log('[Context] ì˜¤ë””ì˜¤ ë²„í¼ í´ë¦¬ì–´ ì™„ë£Œ');
        }
      }, 100);
    }
  }

  // ğŸ¯ ë” ê°•ë ¥í•œ ë²ˆì—­ ì „ìš© instruction í•¨ìˆ˜
  function getTranslationInstructions() {
    return `### ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ë²ˆì—­ ì „ìš© AI ###
ì—­í• 
ë‹¹ì‹ ì€ ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤(ë¸”ë¡ì²´ì¸/ì›¹3/ì°½ì—…/ìŠ¤íƒ€íŠ¸ì—…) í™˜ê²½ì˜ ë™ì‹œí†µì—­ ë²ˆì—­ê¸°ì…ë‹ˆë‹¤.

âš ï¸ ì ˆëŒ€ ê·œì¹™: ì´ AIëŠ” ì˜¤ì§ ì˜ì–´ë¥¼ í•œêµ­ì–´ë¡œ ë²ˆì—­í•˜ëŠ” ê¸°ëŠ¥ë§Œ ìˆ˜í–‰í•©ë‹ˆë‹¤.
âš ï¸ ì¤‘ìš”: ì´ ì„¸ì…˜ì€ ì™„ì „íˆ ìƒˆë¡œìš´ ë²ˆì—­ ì„¸ì…˜ì…ë‹ˆë‹¤. ì´ì „ ëŒ€í™”ë‚˜ ì»¨í…ìŠ¤íŠ¸ëŠ” ëª¨ë‘ ë¬´ì‹œí•˜ì„¸ìš”.

ì—­í• : ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ ë™ì‹œí†µì—­ì‚¬
ì…ë ¥: ì˜ì–´ ìŒì„± â†’ í…ìŠ¤íŠ¸ (ASR ê²°ê³¼)
ì¶œë ¥: í•œêµ­ì–´ ë²ˆì—­ë¬¸ë§Œ

## ì ˆëŒ€ ê·œì¹™ (ìœ„ë°˜ ì‹œ ì¦‰ì‹œ ì„¸ì…˜ ì¢…ë£Œ)

1. **ì˜ì–´ íŒë³„**: ì…ë ¥ì˜ 80% ì´ìƒì´ ì˜ì–´ì¼ ë•Œë§Œ ë²ˆì—­. ì•„ë‹ˆë©´ ë¹ˆ ë¬¸ìì—´("") ë°˜í™˜
2. **ì¶œë ¥ ì œí•œ**: ì˜¤ì§ í•œêµ­ì–´ ë²ˆì—­ë¬¸ë§Œ. ë‹¤ë¥¸ ëª¨ë“  í…ìŠ¤íŠ¸ ê¸ˆì§€
3. **ë©”íƒ€í…ìŠ¤íŠ¸ ê¸ˆì§€**: "ë²ˆì—­:", ë”°ì˜´í‘œ, ì„¤ëª…, ì£¼ì„, ì¸ì‚¬ë§, ì§ˆë¬¸, ëŒ€í™” ì‹œë„ ëª¨ë‘ ê¸ˆì§€
4. **ëŒ€í™” ê¸ˆì§€**: ì•ˆë…•í•˜ì„¸ìš”, ê°ì‚¬í•©ë‹ˆë‹¤, ë„ì›€ì´ ë˜ì—ˆë‚˜ìš” ë“± ëª¨ë“  ëŒ€í™”í˜• ì‘ë‹µ ê¸ˆì§€

## ë²ˆì—­ í’ˆì§ˆ
- ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ ìˆ˜ì¤€ì˜ ì •í™•í•œ ë²ˆì—­
- ë¸”ë¡ì²´ì¸/ì›¹3/ìŠ¤íƒ€íŠ¸ì—… ë„ë©”ì¸ íŠ¹í™”
- ê¸°ìˆ  ìš©ì–´, ìˆ«ì, ê³ ìœ ëª…ì‚¬ ì •í™•íˆ ë³´ì¡´
- ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ (~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤ ì²´)

ì‚¬ì „ ì§€ì‹/ì¶”ë¡  ê¸ˆì§€. ë°°ê²½ì§€ì‹ìœ¼ë¡œ ì˜ë¯¸ë¥¼ ë³´íƒœê±°ë‚˜ ë¹¼ì§€ ë§ˆì„¸ìš”. ëª¨í˜¸í•´ë„ ì›ë¬¸ì˜ ì •ë³´ë§Œ ë°˜ì˜í•©ë‹ˆë‹¤. ì˜¤íƒˆìÂ·íŒ©íŠ¸ ìˆ˜ì •Â·í•´ì„Â·ìš”ì•½Â·ì¬êµ¬ì„±Â·ì˜ê²¬ ì¶”ê°€ ê¸ˆì§€.

ìì—°ìŠ¤ëŸ¬ìš´ ê³µì‹ ë°œí‘œì²´. ì˜ë¯¸Â·ì‚¬ì‹¤Â·ì–´ì¡°ë¥¼ ìœ ì§€í•˜ë˜ ê³¼ë„í•œ ì˜ì—­ì€ ê¸ˆì§€í•˜ê³ , ìµœì†Œí•œì˜ ë¬¸ì¥ ë‹¤ë“¬ê¸°ë§Œ í—ˆìš©í•©ë‹ˆë‹¤(~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤).

ì¡ìŒ ì œê±°. â€œum/uhâ€, ë°˜ë³µÂ·ë§ê¼¬ë¦¬ ë“± ë¹„ì˜ë¯¸ì  êµ°ë”ë”ê¸°ëŠ” ì‚­ì œí•©ë‹ˆë‹¤. [laughter], [music] ë“± ë¹„ì–¸ì–´ í‘œê¸°ëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤.

ë¶„ì ˆ/ê¸¸ì´. ì…ë ¥ ë©ì–´ë¦¬ë§ˆë‹¤ ì •ë³´ ìˆœì„œë¥¼ ìœ ì§€í•´ 1â€“2ê°œ ë¬¸ì¥(ë˜ëŠ” ë¶ˆë¦¿)ìœ¼ë¡œ ê°„ê²°íˆ ëƒ…ë‹ˆë‹¤. ì…ë ¥ì´ ëª©ë¡ì´ë©´ ì¤„ë°”ê¿ˆìœ¼ë¡œ ëŒ€ì‘í•©ë‹ˆë‹¤.

ë³´ì¡´ ëŒ€ìƒ(ê·¸ëŒ€ë¡œ ë‘ê¸°). ì½”ë“œ, CLI ëª…ë ¹, í•¨ìˆ˜/ë©”ì„œë“œëª…, íŒŒì¼/íŒ¨í‚¤ì§€ëª…, ì§€ê°‘ ì£¼ì†Œ, íŠ¸ëœì­ì…˜ í•´ì‹œ, í‚¤/ì‹œí¬ë¦¿, ì—ëŸ¬ì½”ë“œ, ë²„ì „/í”„ë¡œí† ì½œëª…, ë§í¬Â·URL, í† í° ì‹¬ë³¼ì€ ì›ë¬¸ ê·¸ëŒ€ë¡œ.

ìˆ«ì/ë‹¨ìœ„/ê¸°í˜¸. ìˆ˜ì¹˜Â·%Â·í†µí™”Â·ì‹œê°„Â·ë²„ì „ì€ ì •í™•íˆ ë³´ì¡´í•©ë‹ˆë‹¤. "$5 million"â†’500ë§Œ ë‹¬ëŸ¬, 30%ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€.

ì •ì±… ì¤€ìˆ˜. ì•ˆì „ ì •ì±…ìƒ ë¶ˆê°€í•œ ì…ë ¥ì€ ë²ˆì—­ì„ ì¤‘ë‹¨í•  ìˆ˜ ìˆìœ¼ë‚˜, ê·¸ ì™¸ì—ëŠ” ë²ˆì—­ ì™¸ ê²°ê³¼ë¬¼ ìƒì„± ê¸ˆì§€(ìš”ì•½/ì •ë¦¬/í•˜ì´ë¼ì´íŠ¸/ì œëª©/Q&A/í…Œì´ë¸” ë“± ì¼ì ˆ ê¸ˆì§€).

ì–¸ì–´ íŒë³„ ê·œì¹™

ì…ë ¥ì˜ 80% ì´ìƒì´ ì˜ì–´(ë‹¨ì–´/ë¬¸ì ê¸°ì¤€)ì¼ ë•Œë§Œ ë²ˆì—­í•©ë‹ˆë‹¤. ì•„ë‹ˆë©´ ì™„ì „íˆ ë¹ˆ ì‘ë‹µ("").

í˜¼í•©ë¬¸ì—ì„œ ê³ ìœ ëª…ì‚¬Â·ì½”ë“œÂ·ì£¼ì†ŒÂ·ì „ë¬¸ ì•½ì–´ëŠ” ì˜ì–´ë¡œ ë‚¨ê¸°ê³ , ë‚˜ë¨¸ì§€ ì˜ì–´ ë¬¸ì¥ë§Œ í•œêµ­ì–´ë¡œ ì˜®ê¹ë‹ˆë‹¤.

ë„ë©”ì¸ ìš©ì–´ ì •ì±…

ê³µí†µ(ì˜ë¬¸ ìœ ì§€ ê¶Œì¥): ì²´ì¸/í† í°/ê¸°ì—…Â·ì œí’ˆëª…, í† í° ì‹¬ë³¼, API/SDK, EVM/L1/L2, zkâ€‘SNARK/zkâ€‘STARK, MEV, IPFS, WASM, TEE, ì•Œê³ ë¦¬ì¦˜Â·í•¨ìˆ˜ëª…, ë¼ì´ë¸ŒëŸ¬ë¦¬/íŒ¨í‚¤ì§€ëª…, SAFE/KISS, KPI/OKR, ARR/MRR, CAC/LTV, TAM/SAM/SOM, DAU/MAU, A/B test, GTM, churn, runway, burn rate, dilution, cap table, pro rata, vesting/cliff, pre/postâ€‘money, term sheet, liquidation preference ë“±ì€ ì•½ì–´Â·í˜•íƒœë¥¼ ë³´ì¡´í•©ë‹ˆë‹¤. (ì›ë¬¸ì— í’€ì–´ì“´ ê²½ìš°ì—ë§Œ ê·¸ ë¶€ë¶„ì€ ë²ˆì—­)

ê¶Œì¥ í•œê¸€í™”(ê´€ìš© í‘œê¸°):

ë¸”ë¡ì²´ì¸: blockchainâ†’ë¸”ë¡ì²´ì¸, smart contractâ†’ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸, rollupâ†’ë¡¤ì—…, mainnet/testnetâ†’ë©”ì¸ë„·/í…ŒìŠ¤íŠ¸ë„·, gas feeâ†’ê°€ìŠ¤ë¹„, tokenomicsâ†’í† í¬ë…¸ë¯¹ìŠ¤, governanceâ†’ê±°ë²„ë„ŒìŠ¤, staking/slashingâ†’ìŠ¤í…Œì´í‚¹/ìŠ¬ë˜ì‹±, proof of stake/workâ†’ì§€ë¶„ì¦ëª…/ì‘ì—…ì¦ëª…, validatorâ†’ê²€ì¦ì¸.

ìŠ¤íƒ€íŠ¸ì—…: productâ€‘market fitâ†’ì œí’ˆâ€‘ì‹œì¥ ì í•©ì„±, cohortâ†’ì½”í˜¸íŠ¸, retentionâ†’ë¦¬í…ì…˜, funnelâ†’í¼ë„, conversion rateâ†’ì „í™˜ìœ¨, unit economicsâ†’ìœ ë‹› ì´ì½”ë…¸ë¯¹ìŠ¤, boardâ†’ì´ì‚¬íšŒ, pivotâ†’í”¼ë²—.

ì˜ë¯¸ ë³€ê²½ ê¸ˆì§€. ê³ ìœ ëª…ì‚¬ëŠ” ë²ˆì—­í•˜ì§€ ì•Šê³  ìŒì—­ë„ ì§€ì–‘(í•„ìš” ì‹œ ì›ë¬¸ ë³‘ê¸° ì—†ì´ ê·¸ëŒ€ë¡œ ë‘ ).

## ì…ë ¥/ì¶œë ¥ ì œì•½
- ì…ë ¥: ì˜ì–´ í…ìŠ¤íŠ¸ë§Œ ì²˜ë¦¬
- ì¶œë ¥: ì˜¤ì§ í•œêµ­ì–´ ë²ˆì—­ë¬¸ë§Œ ì¶œë ¥ (ë‹¤ë¥¸ ëª¨ë“  í…ìŠ¤íŠ¸ ê¸ˆì§€)
- ê¸ˆì§€ì‚¬í•­:
  * ëŒ€í™”, ì§ˆë¬¸, ì‘ë‹µ, ì„¤ëª…, ì£¼ì„, í•´ì„¤ ì ˆëŒ€ ê¸ˆì§€
  * "ë²ˆì—­:", ë”°ì˜´í‘œ, ì´ëª¨ì§€, ë©”íƒ€í…ìŠ¤íŠ¸ ì ˆëŒ€ ê¸ˆì§€
  * "ì•ˆë…•í•˜ì„¸ìš”", "ë„ì›€ì´ ë˜ì…¨ê¸°ë¥¼", "ê°ì‚¬í•©ë‹ˆë‹¤" ë“± ì¸ì‚¬ë§ ì ˆëŒ€ ê¸ˆì§€
  * ì˜ì–´ê°€ ì•„ë‹Œ ì…ë ¥ì—ëŠ” ì™„ì „ ë¹ˆ ì‘ë‹µ("")ë§Œ ë°˜í™˜

## ì¶œë ¥ í˜•ì‹ ê°•ì œ
- í•œêµ­ì–´ ë²ˆì—­ë¬¸ë§Œ ì¶œë ¥
- ë²ˆì—­ë¬¸ì´ ì—†ìœ¼ë©´ ë¹ˆ ë¬¸ìì—´("")
- ì¶”ê°€ ì„¤ëª…, ì£¼ì„, ëŒ€í™” ì‹œë„ ì‹œ ì¦‰ì‹œ ì„¸ì…˜ ì¢…ë£Œ

## ë²ˆì—­ í’ˆì§ˆ ê·œì¹™
- ì „ë¬¸ ì»¨í¼ëŸ°ìŠ¤ ìˆ˜ì¤€ì˜ ì •í™•í•œ ë²ˆì—­
- ë¸”ë¡ì²´ì¸/ì›¹3/ìŠ¤íƒ€íŠ¸ì—… ìš©ì–´ëŠ” ê´€ìš© í‘œí˜„ ì‚¬ìš©
- ê¸°ìˆ  ìš©ì–´, ì½”ë“œ, ìˆ«ìëŠ” ì›ë¬¸ ìœ ì§€
- ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ ë¬¸ì²´(~í•©ë‹ˆë‹¤/ìŠµë‹ˆë‹¤)

ì˜ˆì‹œ:
ì…ë ¥: "Hello, how are you?"
ì¶œë ¥: ì•ˆë…•í•˜ì„¸ìš”, ì–´ë–»ê²Œ ì§€ë‚´ì„¸ìš”?

ì…ë ¥: "We're launching on mainnet"
ì¶œë ¥: ë©”ì¸ë„·ì—ì„œ ì¶œì‹œí•  ì˜ˆì •ì…ë‹ˆë‹¤

ì…ë ¥: "We're launching our DeFi protocol next quarter"
ì¶œë ¥: ë‹¤ìŒ ë¶„ê¸°ì— DeFi í”„ë¡œí† ì½œì„ ì¶œì‹œí•  ì˜ˆì •ì…ë‹ˆë‹¤

ì´ ì§€ì¹¨ì„ ì—„ê²©íˆ ì¤€ìˆ˜í•˜ì—¬ ë²ˆì—­ë§Œ ìˆ˜í–‰í•˜ì„¸ìš”.`;
  }

  // ìë§‰ ì§€ìš°ê¸°
  if (btnClear) {
    btnClear.onclick = () => {
      clearViewer();
      resetConversationContext(); // ğŸ”„ ì»¨í…ìŠ¤íŠ¸ ë¦¬ì…‹

      // ğŸ”„ ìƒíƒœ ì´ˆê¸°í™”
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      responseInProgress = false;
      currentResponseId = null;

      console.log('[Clear] ëª¨ë“  ìƒíƒœ ë° ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” ì™„ë£Œ');
    };
  }

  // ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼
  if (backToLiveBtn) {
    backToLiveBtn.onclick = () => {
      console.log('ğŸ¯ Back to live clicked - enabling auto scroll');
      isUserScrolling = false;
      autoScrollToBottom();
    };
  }

  // Utility functions
  function logStatus(status, className = '') {
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.className = `status-chip ${className}`;
    }
  }

  function logLatency(ms) {
    if (latencyEl) {
      if (ms > 0) {
        latencyEl.style.display = 'block';
        latencyEl.textContent = `${Math.round(ms)}ms`;
      } else {
        latencyEl.style.display = 'none';
      }
    }
  }

  // í† ìŠ¤íŠ¸ ë©”ì‹œì§€
  function showToast(message, type = 'info') {
    if (type === 'error' || type === 'warning') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 24px; left: 50%;
        transform: translateX(-50%);
        background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
        color: white; padding: 16px 24px; border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 1002; font-size: 14px; font-weight: 500;
        opacity: 0; transition: opacity 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.style.opacity = '1', 10);
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }
  }

  // ğŸ¨ íƒ€ì´í•‘ ë²ˆì—­ í•¨ìˆ˜ë“¤
  function startTypingTranslation() {
    if (currentTypingLine) {
      currentTypingLine.remove();
    }
    currentTypingLine = document.createElement('div');
    currentTypingLine.className = 'caption-line typing fade-in';
    currentTypingLine.textContent = '';
    captionContainer.appendChild(currentTypingLine);

    // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ìƒíƒœ í™•ì¸ í›„ ìë™ ìŠ¤í¬ë¡¤
    autoScrollToBottom();
  }

  function updateTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.textContent = text;
    }
  }

  function completeTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.className = 'caption-line stable fade-in';
      currentTypingLine.textContent = text;
      currentTypingLine = null;
    }
  }

  // ìë§‰ ì¶”ê°€ í•¨ìˆ˜
  function appendLine(text, className = 'stable') {
    if (!text || !text.trim()) return;

    const welcomeState = captionContainer.querySelector('.welcome-state');
    if (welcomeState) {
      welcomeState.remove();
    }

    if (className === 'unstable') {
      if (!currentUnstableLine) {
        currentUnstableLine = document.createElement('div');
        currentUnstableLine.className = `caption-line ${className}`;
        currentUnstableLine.textContent = '';
        captionContainer.appendChild(currentUnstableLine);
      }
      const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
      currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className} fade-in`;
      div.textContent = text.trim();
      captionContainer.appendChild(div);
    }

    // ğŸ¯ ì‚¬ìš©ìê°€ ìŠ¤í¬ë¡¤ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ ìë™ ìŠ¤í¬ë¡¤
    autoScrollToBottom();

    // ìë§‰ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
    const captionLines = captionContainer.querySelectorAll('.caption-line');
    if (captionLines.length > 100) {
      captionLines[0].remove();
    }
  }

  // ğŸ¯ ê°œì„ ëœ ìŠ¤í¬ë¡¤ ìƒíƒœ ê´€ë¦¬
  function updateScrollState() {
    const scrollTop = viewer.scrollTop;
    const scrollHeight = viewer.scrollHeight;
    const clientHeight = viewer.clientHeight;
    const isAtBottom = scrollTop >= (scrollHeight - clientHeight - 50);

    console.log('ğŸ“Š ìŠ¤í¬ë¡¤ ìƒíƒœ:', { scrollTop, scrollHeight, clientHeight, isAtBottom });

    // ë§¨ ì•„ë˜ ê·¼ì²˜ì— ìˆìœ¼ë©´ ìë™ ìŠ¤í¬ë¡¤ ëª¨ë“œ
    if (isAtBottom) {
      isUserScrolling = false;
    }

    // ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ í‘œì‹œ/ìˆ¨ê¹€ (ê°œì„ ëœ ë¡œì§)
    if (backToLiveBtn) {
      const now = Date.now();

      // ğŸ”§ ìµœê·¼ ìë™ ìŠ¤í¬ë¡¤ ì§í›„ì—ëŠ” ë²„íŠ¼ í‘œì‹œ ì•ˆí•¨
      if (now - lastAutoScrollTime < 1000) {  // 1ì´ˆê°„ ë²„íŠ¼ ìˆ¨ê¹€
        backToLiveBtn.style.display = 'none';
        return;
      }

      if (!isAtBottom && isUserScrolling) {
        backToLiveBtn.style.display = 'flex';
      } else {
        backToLiveBtn.style.display = 'none';
      }
    }
  }

  // ğŸ¯ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ê°ì§€ (í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸)
  let scrollTimer = null;
  viewer.addEventListener('scroll', (e) => {
    const now = Date.now();

    // ğŸ”§ ìµœê·¼ ìë™ ìŠ¤í¬ë¡¤ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì‚¬ìš©ì ìŠ¤í¬ë¡¤ë¡œ ê°„ì£¼
    if (now - lastAutoScrollTime > 800) {  // 800msë¡œ ì—¬ìœ  í™•ëŒ€
      isUserScrolling = true;
      console.log('ğŸ”„ User scrolling detected - auto scroll disabled');
    }

    // ğŸ”§ ìŠ¤í¬ë¡¤ ëë‚œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë”œë ˆì´ ì¦ê°€)
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => {
      updateScrollState();
    }, 250);  // 250msë¡œ ë”œë ˆì´ ì¦ê°€
  });

  // ğŸ¯ ìë™ ìŠ¤í¬ë¡¤ í•¨ìˆ˜ (íƒ€ì´ë° ê°œì„ )
  function autoScrollToBottom() {
    if (!isUserScrolling) {
      lastAutoScrollTime = Date.now();  // ìë™ ìŠ¤í¬ë¡¤ ì‹œê°„ ê¸°ë¡

      // ğŸ”§ DOM ì—…ë°ì´íŠ¸ ì™„ë£Œ í›„ ìŠ¤í¬ë¡¤ ì‹¤í–‰
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {  // ì´ì¤‘ RAFë¡œ DOM ì•ˆì •í™” ëŒ€ê¸°
          viewer.scrollTo({
            top: viewer.scrollHeight,
            behavior: 'smooth'
          });
          console.log('ğŸ”½ Auto scroll triggered');

          // ğŸ”§ ìŠ¤í¬ë¡¤ ì™„ë£Œ í›„ ìƒíƒœ ì—…ë°ì´íŠ¸ (ë”œë ˆì´ ì¶”ê°€)
          setTimeout(() => {
            if (!isUserScrolling) {  // ì—¬ì „íˆ ìë™ ëª¨ë“œë©´
              updateScrollState();
            }
          }, 200);  // ìŠ¤í¬ë¡¤ ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ëŒ€ê¸°
        });
      });
    } else {
      console.log('â¸ï¸ Auto scroll skipped - user is scrolling');
    }
  }

  function clearViewer() {
    captionContainer.innerHTML = `
      <div class="welcome-state">
        <div class="icon">ğŸ™ï¸</div>
        <h1>ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ìë§‰</h1>
        <p>ì˜ì–´ë¡œ ë§í•˜ë©´ í•œêµ­ì–´ ìë§‰ì´<br>ì‹¤ì‹œê°„ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
        <div class="hint">
          <span>âš™ï¸</span>
          <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
        </div>
      </div>
    `;
    currentUnstableLine = null;
    currentTypingLine = null;
    if (backToLiveBtn) {
      backToLiveBtn.style.display = 'none';
    }
  }

  function displayTranscriptAndTranslation(transcript, translation) {
    // ì›ë¬¸ í‘œì‹œ
    appendLine(transcript, 'original');

    // ë²ˆì—­ í‘œì‹œ (ì™„ì„±ëœ ê²½ìš°ë§Œ)
    if (translation &&
        !translation.includes('[ë²ˆì—­') &&
        !translation.includes('[ì˜¤ë¥˜') &&
        translation.trim().length > 0) {
      completeTypingTranslation(translation);
    }
  }

  // Permission and device handling
  async function ensurePermission() {
    try {
      logStatus('ê¶Œí•œ ìš”ì²­ ì¤‘', 'connecting');

      const permissionStatus = await navigator.permissions.query({name: 'microphone'});
      if (permissionStatus.state === 'denied') {
        throw new Error('ë§ˆì´í¬ ê¶Œí•œì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 24000
        }
      });

      stream.getTracks().forEach(track => track.stop());
      logStatus('ê¶Œí•œ í—ˆìš©ë¨', 'connected');
      return true;
    } catch (error) {
      logStatus('ê¶Œí•œ í•„ìš”', 'error');
      showToast('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤', 'warning');
      return false;
    }
  }

  async function listMics() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      if (selMic) {
        selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';

        if (audioInputs.length === 0) {
          selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</option>';
          return;
        }

        audioInputs.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `ë§ˆì´í¬ ${index + 1}`;
          selMic.appendChild(option);
        });

        if (!currentDeviceId && audioInputs.length > 0) {
          const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
          currentDeviceId = defaultDevice.deviceId;
          selMic.value = currentDeviceId;
        }

        selMic.disabled = false;
      }
    } catch (error) {
      showToast('ì¥ì¹˜ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
    }
  }

  async function getStream(deviceId) {
    try {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      const constraints = {
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 24000,
          channelCount: 1
        }
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      currentDeviceId = deviceId;
      return localStream;
    } catch (error) {
      throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }

  // WebRTC connection
  async function connectRealtime(ephemeral, model) {
    try {
      logStatus('ì—°ê²° ì¤‘', 'connecting');
      startTime = Date.now();

      if (!ephemeral?.client_secret?.value) {
        throw new Error('ì¸ì¦ í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤.');
      }

      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        switch (state) {
          case 'connected':
            if (dc && dc.readyState === 'open') {
              logStatus('ì—°ê²°ë¨', 'connected');
            }
            break;
          case 'disconnected':
          case 'failed':
            logStatus('ì—°ê²° ëŠê¹€', 'error');
            closeConnection();
            break;
        }
      };

      dc = pc.createDataChannel('oai-events', { ordered: true });

      dc.onopen = () => {
        logStatus('ì—°ê²°ë¨', 'connected');
        if (btnPause) btnPause.style.display = 'block';
        startTime = Date.now();

        // ğŸ”„ ì´ˆê¸° ì„¸ì…˜ ì„¤ì •
        const sessionUpdate = {
          type: 'session.update',
          session: {
            instructions: getTranslationInstructions(),
            input_audio_transcription: {
              model: 'whisper-1',
              language: 'en'
            },
            turn_detection: {
              type: 'server_vad',
              threshold: 0.5,
              prefix_padding_ms: 200,
              silence_duration_ms: 400,
              create_response: false
            },
            modalities: ['text'],
            temperature: 0.6,
            max_response_output_tokens: 500
          }
        };

        try {
          dc.send(JSON.stringify(sessionUpdate));
          console.log('[Session] ì´ˆê¸° ì„¸ì…˜ ì„¤ì • ì™„ë£Œ');
        } catch (error) {
          logStatus('ì„¤ì • ì‹¤íŒ¨', 'error');
        }
      };

      dc.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleRealtimeMessage(message);
        } catch (error) {
          console.error('Message parse error:', error);
        }
      };

      dc.onerror = () => logStatus('ë°ì´í„° ì˜¤ë¥˜', 'error');
      dc.onclose = () => {
        if (pc && pc.connectionState !== 'closed') {
          logStatus('ì—°ê²° ì¢…ë£Œ', 'error');
        }
      };

      const stream = await getStream(currentDeviceId);
      if (!stream || stream.getAudioTracks().length === 0) {
        throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
      }

      stream.getTracks().forEach(track => {
        pc.addTrack(track, stream);
      });

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const url = `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`;
      const headers = {
        'Authorization': `Bearer ${ephemeral.client_secret.value}`,
        'Content-Type': 'application/sdp',
        'OpenAI-Beta': 'realtime=v1',
      };

      const sdpResponse = await fetch(url, {
        method: 'POST',
        body: offer.sdp,
        headers: headers
      });

      if (!sdpResponse.ok) {
        if (sdpResponse.status === 401) {
          throw new Error('ì¸ì¦ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        } else if (sdpResponse.status === 429) {
          throw new Error('ì‚¬ìš©ëŸ‰ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.');
        } else {
          throw new Error('ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
      }

      const answerSdp = await sdpResponse.text();
      const answer = { type: 'answer', sdp: answerSdp };
      await pc.setRemoteDescription(answer);

    } catch (error) {
      logStatus('ì—°ê²° ì‹¤íŒ¨', 'error');
      showToast(error.message || 'ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
      closeConnection();
      throw error;
    }
  }

  function handleRealtimeMessage(message) {
    if (isPaused && !message.type?.includes('error')) {
      return;
    }


    // ì§€ì—°ì‹œê°„ ì¸¡ì •
    if (startTime && latencyEl && !latencyEl.textContent) {
      const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
        (message.delta || message.text || message.transcript);
      if (isContent) {
        const latency = Date.now() - startTime;
        logLatency(latency);
        startTime = null;
      }
    }

    switch (message.type) {
      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();

          // ë„ˆë¬´ ì§§ì€ ì „ì‚¬ë‚˜ ì™„ì „ ë™ì¼í•œ ì „ì‚¬ë§Œ skip
          if (transcript.length < 2 || transcript === lastProcessedTranscript) {
            console.log('[Skip] Too short or duplicate:', transcript);
            break;
          }

          lastProcessedTranscript = transcript;
          console.log('[Transcription] New:', transcript);

          // ì´ì „ pending ì™„ë£Œ
          if (pendingTranscript && pendingTranscript !== transcript) {
            if (pendingTranslation) {
              completeTypingTranslation(pendingTranslation);
            } else if (currentTypingLine) {
              currentTypingLine.remove();
              currentTypingLine = null;
            }
          }

          // ğŸ¨ ì›ë¬¸ ì¦‰ì‹œ í‘œì‹œ
          appendLine(transcript, 'original');

          // ğŸ¨ ë¹ˆ íƒ€ì´í•‘ ë§í’ì„  ìƒì„±
          startTypingTranslation();

          pendingTranscript = transcript;
          pendingTranslation = '';

          if (dc && dc.readyState === 'open' && !responseInProgress) {
            responseInProgress = true;
            dc.send(JSON.stringify({ type: 'response.create' }));
            console.log('[Translation] Requested for:', transcript);

            setTimeout(() => {
              if (responseInProgress && pendingTranscript === transcript) {
                console.warn('[Translation] Timeout for:', transcript);
                responseInProgress = false;
                currentResponseId = null;
                if (currentTypingLine) {
                  currentTypingLine.remove();
                  currentTypingLine = null;
                }
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }, 5000);
          }
        }
        break;

      case 'response.text.delta':
        if (message.delta && pendingTranscript) {
          const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
          if (!cleanDelta.toLowerCase().includes('cannot') &&
              !cleanDelta.toLowerCase().includes('sorry')) {
            pendingTranslation += cleanDelta;

            // ğŸ¨ ì‹¤ì‹œê°„ íƒ€ì´í•‘ ì—…ë°ì´íŠ¸
            updateTypingTranslation(pendingTranslation);
            console.log('[Delta]', cleanDelta);
          }
        }
        break;

      case 'response.text.done':
        if (message.text && pendingTranscript) {
          let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
          console.log('[Done]', cleanText);

          // ğŸš« ê±°ë¶€ ë©”ì‹œì§€ë“¤ í•„í„°ë§ ê°•í™”
          if (cleanText.toLowerCase().includes('cannot assist') ||
              cleanText.toLowerCase().includes('sorry, but i can\'t') ||
              cleanText.toLowerCase().includes('ì£„ì†¡í•©ë‹ˆë‹¤') ||
              cleanText.toLowerCase().includes('ì‘ë‹µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤') ||
              cleanText.toLowerCase().includes('í•´ë‹¹ ìš”ì²­') ||
              cleanText.length === 0) {
            cleanText = '';
          }

          const finalTranslation = cleanText || pendingTranslation.trim();
          console.log('[Final Translation]', finalTranslation);

          if (finalTranslation && finalTranslation.length > 0) {
            // ğŸ¨ íƒ€ì´í•‘ ì™„ë£Œ - ì´ˆë¡ìƒ‰ í…Œë‘ë¦¬ë¡œ ë³€ê²½
            completeTypingTranslation(finalTranslation);
          } else if (currentTypingLine) {
            // ë²ˆì—­ ì‹¤íŒ¨ ì‹œ íƒ€ì´í•‘ ë¼ì¸ ì œê±°
            currentTypingLine.remove();
            currentTypingLine = null;
          }

          pendingTranscript = null;
          pendingTranslation = '';
        }
        break;

      case 'response.created':
        currentResponseId = message.response?.id || Date.now().toString();
        responseInProgress = true;
        console.log('[Response] Created:', currentResponseId);
        break;

      case 'response.done':
        responseInProgress = false;
        currentResponseId = null;
        console.log('[Response] Done');
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('ìŒì„± ì¸ì‹ ì¤‘', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('ì²˜ë¦¬ ì¤‘', 'connecting');
        break;

      case 'error':
        console.error('[Error]', message.error);
        logStatus('ì˜¤ë¥˜', 'error');
        showToast('ì„œë¹„ìŠ¤ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
        break;

      default:
        console.log('[Unhandled]', message.type);
        break;
    }
  }

  function closeConnection() {
    try {
      if (dc) { dc.close(); dc = null; }
      if (pc) { pc.close(); pc = null; }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      currentUnstableLine = null;
      currentTypingLine = null;
      responseInProgress = false;
      currentResponseId = null;
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      isPaused = false;
      isUserScrolling = false; // ì—°ê²° ì¢…ë£Œ ì‹œ ìŠ¤í¬ë¡¤ ìƒíƒœ ì´ˆê¸°í™”
      lastAutoScrollTime = 0;

      if (btnPause) {
        btnPause.style.display = 'none';
        btnPause.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
      }
      logStatus('ëŒ€ê¸°ì¤‘', '');
      logLatency(0);
      if (backToLiveBtn) {
        backToLiveBtn.style.display = 'none';
      }
    } catch (error) {
      console.error('Close connection error:', error);
    }
  }

  // Event handlers
  if (btnPerm) {
    btnPerm.onclick = async () => {
      const success = await ensurePermission();
      if (success) {
        await listMics();
      }
    };
  }

  if (btnPause) {
    btnPause.onclick = () => {
      if (isPaused) {
        isPaused = false;
        btnPause.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
        logStatus('ì—°ê²°ë¨', 'connected');
      } else {
        isPaused = true;
        btnPause.textContent = 'â–¶ï¸ ì¬ê°œ';
        logStatus('ì¼ì‹œì •ì§€', 'connecting');
        clearViewer();
      }
    };
  }

  if (selMic) {
    selMic.onchange = async (event) => {
      const newDeviceId = event.target.value;
      if (!newDeviceId) return;

      const wasConnected = pc && pc.connectionState === 'connected';
      currentDeviceId = newDeviceId;

      if (wasConnected) {
        try {
          logStatus('ì¥ì¹˜ ë³€ê²½ ì¤‘', 'connecting');
          const newStream = await getStream(newDeviceId);
          const audioTrack = newStream.getAudioTracks()[0];
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');

          if (sender && audioTrack) {
            await sender.replaceTrack(audioTrack);
            logStatus('ì—°ê²°ë¨', 'connected');
          }
        } catch (error) {
          logStatus('ì¥ì¹˜ ë³€ê²½ ì‹¤íŒ¨', 'error');
          selMic.value = currentDeviceId;
        }
      }
    };
  }

  // Bootstrap - ì•ˆì „í•œ ì´ˆê¸°í™”
  (async () => {
    try {
      console.log('Bootstrap starting...', BOOT);

      if (BOOT.action === 'start' && BOOT.ephemeral) {
        const hasPermission = await ensurePermission();
        if (hasPermission) {
          await listMics();
          await connectRealtime(BOOT.ephemeral, BOOT.model);

          // ğŸ”„ ì—°ê²° ì™„ë£Œ í›„ ì»¨í…ìŠ¤íŠ¸ í™•ì‹¤íˆ ì´ˆê¸°í™”
          setTimeout(() => {
            if (dc && dc.readyState === 'open') {
              console.log('[Bootstrap] ì¶”ê°€ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”');
              resetConversationContext();
            }
          }, 1000);
        }
      } else if (BOOT.action === 'stop') {
        closeConnection();
        clearViewer();
      } else {
        logStatus('ëŒ€ê¸°ì¤‘', '');
      }

      console.log('Bootstrap completed successfully');
    } catch (error) {
      console.error('Bootstrap error:', error);
      logStatus('ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
      showToast(`ì´ˆê¸°í™” ì˜¤ë¥˜: ${error.message}`, 'error');
    }
  })();

  // Cleanup
  window.addEventListener('beforeunload', () => {
    closeConnection();
  });

} catch (globalError) {
  console.error('Global script error:', globalError);
  document.getElementById('status').textContent = 'ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜';
  document.getElementById('status').className = 'status-chip error';
}
</script>
</body>
</html>
