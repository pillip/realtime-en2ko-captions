<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 5% 0 0 0;
      padding: 10px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden !important;
      height: 90vh !important;
      max-height: 90vh !important;
      box-sizing: border-box;
      position: relative;
    }

    /* 🎨 동적 폰트 크기 CSS 변수 */
    :root {
      --translation-font-size: 28px;
      --original-font-size: 16px;
    }

    /* 플로팅 설정 버튼 */
    .settings-fab {
      position: fixed;
      top: calc(24px + 5%);
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* 설정 패널 */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* 🎨 슬라이더 스타일링 */
    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      margin: 8px 0 12px 0;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #059669;
      transform: scale(1.2);
    }

    .control-group span {
      display: inline-block;
      min-width: 60px;
      color: #10b981;
      font-weight: 500;
      font-size: 13px;
    }

    /* 상태 표시 */
    .status-overlay {
      position: absolute;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* 실시간으로 버튼 */
    .back-to-live {
      position: absolute;
      bottom: 32px;
      right: 32px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
    }

    /* 🎯 메인 캡션 뷰어 - 스크롤바 완전 숨김 */
    #viewer {
      height: 100% !important;
      max-height: 100% !important;
      width: 100%;
      padding: 0;
      overflow-y: auto;
      overflow-x: hidden;
      background: transparent;
      scroll-behavior: smooth;
      display: flex;
      align-items: center;
      justify-content: center;
      scrollbar-width: none;        /* Firefox */
      -ms-overflow-style: none;     /* IE and Edge */
      position: relative;
    }

    #viewer::-webkit-scrollbar {
      display: none;                /* Chrome, Safari */
    }

    /* 자막 컨테이너 */
    .caption-container {
      width: 100%;
      max-width: 1200px;
      padding: 10px 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0;
      padding-bottom: 80px;
      min-height: 100%;
      box-sizing: border-box;
    }

    .caption-line {
      margin-bottom: 16px;
      line-height: 1.4;
      padding: 16px 24px;
      border-radius: 12px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }

    /* 원문 스타일 */
    .caption-line.original {
      font-size: var(--original-font-size);
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 8px;
      font-weight: 300;
      max-width: 85%;
      transition: all 0.3s ease;
      padding: 12px 20px;
    }

    /* 원문 숨김 상태 */
    .hide-original .caption-line.original {
      display: none !important;
    }

    /* 번역된 자막 스타일 */
    .caption-line.stable {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* 🎨 타이핑 중인 번역 말풍선 */
    .caption-line.typing {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #fbbf24;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
      animation: typing-breathe 1.5s ease-in-out infinite;
      position: relative;
    }

    /* 타이핑 커서 효과 */
    .caption-line.typing::after {
      content: '|';
      color: #fbbf24;
      animation: cursor-blink 1s ease-in-out infinite;
      margin-left: 2px;
    }

    @keyframes typing-breathe {
      0%, 100% {
        border-left-color: #fbbf24;
      }
      50% {
        border-left-color: #f59e0b;
        box-shadow: 0 8px 32px rgba(251, 191, 36, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* 실시간 입력 중 */
    .caption-line.unstable {
      font-size: calc(var(--translation-font-size) - 2px);
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    /* 🎨 말풍선 등장 애니메이션 */
    .caption-line.fade-in {
      animation: fadeInUp 0.4s ease-out forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* 빈 상태 */
    .welcome-state {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* 반응형 디자인 - 너비 기준 */
    @media (max-width: 768px) {
      body {
        padding: 5px;
        height: 90vh !important;
        max-height: 90vh !important;
      }

      .settings-panel {
        width: 100%;
      }

      .caption-container {
        padding: 5px 10px;
        padding-bottom: 60px;
      }

      .caption-line {
        margin-bottom: 12px;
        padding: 12px 16px;
      }

      .caption-line.stable, .caption-line.typing {
        font-size: calc(var(--translation-font-size) * 0.8);
        max-width: 95%;
      }

      .caption-line.original {
        font-size: calc(var(--original-font-size) * 0.9);
        padding: 8px 12px;
        margin-bottom: 6px;
      }

      .status-overlay {
        bottom: 10px;
        left: 10px;
      }

      .back-to-live {
        bottom: 10px;
        right: 10px;
        padding: 8px 16px;
        font-size: 12px;
      }

      .settings-fab {
        top: calc(10px + 5%);
        right: 10px;
        width: 48px;
        height: 48px;
        font-size: 20px;
      }
    }

    /* 높이 기준 미디어쿼리 - 더 컴팩트 */
    @media (max-height: 600px) {
      body {
        padding: 5px;
        height: 90vh !important;
        max-height: 90vh !important;
      }

      .caption-container {
        padding: 5px 10px;
        padding-bottom: 40px;
      }

      .caption-line {
        margin-bottom: 8px;
        padding: 8px 12px;
        line-height: 1.3;
      }

      .caption-line.original {
        margin-bottom: 4px;
        padding: 6px 10px;
      }

      .settings-panel {
        padding: 40px 15px 15px;
      }

      .status-overlay {
        bottom: 5px;
        left: 5px;
      }

      .back-to-live {
        bottom: 5px;
        right: 5px;
        padding: 6px 12px;
        font-size: 11px;
      }

      .settings-fab {
        top: calc(5px + 5%);
        right: 5px;
        width: 40px;
        height: 40px;
        font-size: 18px;
      }
    }
  </style>
</head>

<body>
  <!-- 플로팅 설정 버튼 -->
  <button class="settings-fab" id="settingsFab">⚙️</button>

  <!-- 설정 패널 -->
  <div class="settings-panel" id="settingsPanel">
    <h2>실시간 자막 설정</h2>

    <div class="control-group">
      <label>마이크 권한</label>
      <button id="btnPerm">🎤 마이크 권한 요청</button>
    </div>

    <div class="control-group">
      <label>오디오 장치</label>
      <select id="selMic" disabled>
        <option value="">마이크를 선택하세요</option>
      </select>
    </div>

    <!-- 🎨 폰트 크기 조절 -->
    <div class="control-group">
      <label>📝 번역 글자 크기</label>
      <input type="range" id="fontSizeSlider" min="18" max="48" value="28" step="2" class="slider">
      <span id="fontSizeValue">28px</span>
    </div>

    <div class="control-group">
      <label>📄 원문 글자 크기</label>
      <input type="range" id="originalSizeSlider" min="12" max="24" value="16" step="1" class="slider">
      <span id="originalSizeValue">16px</span>
    </div>

    <!-- 원문 표시 토글 -->
    <div class="control-group">
      <label style="display: flex; align-items: center; cursor: pointer;">
        <input type="checkbox" id="showOriginalToggle" style="margin-right: 8px; width: 16px; height: 16px;">
        <span>🔤 원문 표시</span>
      </label>
    </div>

    <!-- 🚫 제어 섹션 완전 제거 (일시정지, 자막 지우기 버튼 삭제) -->
  </div>

  <!-- 상태 표시 -->
  <div class="status-overlay">
    <div id="status" class="status-chip">대기중</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- 실시간으로 버튼 -->
  <button class="back-to-live" id="backToLive">
    📺 실시간으로
    <span style="margin-left: 4px;">⬇️</span>
  </button>

  <!-- 메인 캡션 뷰어 -->
  <div id="viewer">
    <div class="caption-container" id="captionContainer">
      <div class="welcome-state">
        <div class="icon">🎙️</div>
        <h1>실시간 한영 자막</h1>
        <p>한국어와 영어로 말하면<br>실시간 자막과 번역이 나타납니다</p>
        <div class="hint">
          <span>⚙️</span>
          <span>우상단 설정에서 마이크를 활성화하세요</span>
        </div>
        <div style="margin-top: 16px; font-size: 14px; color: rgba(255, 255, 255, 0.5);">
          <div>🔄 번역 규칙:</div>
          <div>• 한국어 → 영어</div>
          <div>• 영어 → 한국어</div>
        </div>
      </div>
    </div>
  </div>

<script>
  // Web Speech API + AWS WebSocket 연결 사용

try {
  // Bootstrap data
  const BOOT = {{BOOTSTRAP_JSON}};
  console.log('BOOT data:', BOOT);

  // AWS Configuration
  let awsConfig = null;
  if (BOOT.aws_session) {
    awsConfig = {
      region: BOOT.aws_session.region,
      credentials: {
        accessKeyId: BOOT.aws_session.access_key_id,
        secretAccessKey: BOOT.aws_session.secret_access_key,
      }
    };
  }

  // Global state
  let awsWebSocket = null;
  let localStream = null;
  let currentDeviceId = null;
  let startTime = null;
  let currentUnstableLine = null;
  let currentTypingLine = null;  // 🎨 타이핑 라인
  let responseInProgress = false;
  let currentResponseId = null;
  let pendingTranscript = null;
  let pendingTranslation = '';
  let lastProcessedTranscript = null;
  let lastTranslationRequest = null;
  let translationRequestTime = 0;
  let isPaused = false;
  let isUserScrolling = false;    // 🎯 사용자 스크롤 상태
  let lastAutoScrollTime = 0;     // 🎯 마지막 자동 스크롤 시간

  // DOM elements with null checks
  const viewer = document.getElementById('viewer');
  const captionContainer = document.getElementById('captionContainer');
  const selMic = document.getElementById('selMic');
  const statusEl = document.getElementById('status');
  const latencyEl = document.getElementById('latency');
  const btnPerm = document.getElementById('btnPerm');
  const settingsFab = document.getElementById('settingsFab');
  const settingsPanel = document.getElementById('settingsPanel');
  const backToLiveBtn = document.getElementById('backToLive');
  const fontSizeSlider = document.getElementById('fontSizeSlider');
  const fontSizeValue = document.getElementById('fontSizeValue');
  const originalSizeSlider = document.getElementById('originalSizeSlider');
  const originalSizeValue = document.getElementById('originalSizeValue');
  const showOriginalToggle = document.getElementById('showOriginalToggle');

  // Null check for critical elements
  if (!viewer || !captionContainer || !statusEl) {
    throw new Error('필수 DOM 요소를 찾을 수 없습니다.');
  }

  // localStorage에서 설정 불러오기
  const loadSettings = () => {
    // 원문 표시 설정 (기본값: false = 숨김)
    const showOriginal = localStorage.getItem('showOriginal') === 'true';
    if (showOriginalToggle) {
      showOriginalToggle.checked = showOriginal;
    }
    // 초기 상태 적용
    if (!showOriginal) {
      captionContainer.classList.add('hide-original');
    }

    // 폰트 크기 설정
    const translationSize = localStorage.getItem('translationFontSize') || '28';
    const originalSize = localStorage.getItem('originalFontSize') || '16';

    if (fontSizeSlider && fontSizeValue) {
      fontSizeSlider.value = translationSize;
      fontSizeValue.textContent = `${translationSize}px`;
      document.documentElement.style.setProperty('--translation-font-size', `${translationSize}px`);
    }

    if (originalSizeSlider && originalSizeValue) {
      originalSizeSlider.value = originalSize;
      originalSizeValue.textContent = `${originalSize}px`;
      document.documentElement.style.setProperty('--original-font-size', `${originalSize}px`);
    }
  };

  // 설정 초기화
  loadSettings();

  // 🎨 폰트 크기 조절 이벤트 핸들러 (null check 포함)
  if (fontSizeSlider && fontSizeValue) {
    fontSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--translation-font-size', `${size}px`);
      fontSizeValue.textContent = `${size}px`;
      localStorage.setItem('translationFontSize', size);
    };
  }

  if (originalSizeSlider && originalSizeValue) {
    originalSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--original-font-size', `${size}px`);
      originalSizeValue.textContent = `${size}px`;
      localStorage.setItem('originalFontSize', size);
    };
  }

  // 원문 표시 토글 이벤트 핸들러
  if (showOriginalToggle) {
    showOriginalToggle.onchange = (e) => {
      const showOriginal = e.target.checked;
      if (showOriginal) {
        captionContainer.classList.remove('hide-original');
      } else {
        captionContainer.classList.add('hide-original');
      }
      localStorage.setItem('showOriginal', showOriginal);
      console.log('원문 표시:', showOriginal ? '활성화' : '비활성화');
    };
  }

  // 설정 패널 토글
  if (settingsFab && settingsPanel) {
    settingsFab.onclick = () => {
      settingsPanel.classList.toggle('open');
      settingsFab.classList.toggle('active');
    };
  }

  // 설정 패널 외부 클릭시 닫기
  document.addEventListener('click', (e) => {
    if (settingsPanel && settingsFab &&
        !settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
      settingsPanel.classList.remove('open');
      settingsFab.classList.remove('active');
    }
  });

  // 🔄 대화 컨텍스트 초기화 함수 추가
  // 🚫 컨텍스트 리셋 함수 완전 제거 (에러 원인 제거)
  // function resetConversationContext() { ... } ← 삭제

  // 🎯 한영 번역 전용 instruction 함수
  function getTranslationInstructions() {
    return `### 실시간 한영 양방향 번역 AI ###
역할
당신은 전문 컨퍼런스(블록체인/웹3/창업/스타트업) 환경의 한영 동시통역 번역기입니다.

⚠️ 절대 규칙: 이 AI는 오직 한국어↔영어 번역 기능만 수행합니다.
⚠️ 중요: 이 세션은 완전히 새로운 번역 세션입니다. 이전 대화나 컨텍스트는 모두 무시하세요.

역할: 전문 컨퍼런스 한영 동시통역사
입력: 한국어 또는 영어 음성 → 텍스트 (ASR 결과)
출력: 반대 언어로 번역된 텍스트만

## 절대 규칙 (위반 시 즉시 세션 종료)

1. **언어 판별 및 번역**:
   - 한국어 입력 → 영어로 번역
   - 영어 입력 → 한국어로 번역
   - 한영 혼용 → 전체를 반대 언어로 번역
2. **출력 제한**: 오직 번역문만. 다른 모든 텍스트 금지
3. **메타텍스트 금지**: "번역:", 따옴표, 설명, 주석, 인사말, 질문, 대화 시도 모두 금지
4. **대화 금지**: 안녕하세요, 감사합니다, 도움이 되었나요 등 모든 대화형 응답 금지

## 번역 품질
- 전문 컨퍼런스 수준의 정확한 번역
- 블록체인/웹3/스타트업 도메인 특화
- 기술 용어, 숫자, 고유명사 정확히 보존
- 자연스러운 한국어 (~합니다/습니다 체)

사전 지식/추론 금지. 배경지식으로 의미를 보태거나 빼지 마세요. 모호해도 원문의 정보만 반영합니다. 오탈자·팩트 수정·해석·요약·재구성·의견 추가 금지.

자연스러운 공식 발표체. 의미·사실·어조를 유지하되 과도한 의역은 금지하고, 최소한의 문장 다듬기만 허용합니다(~합니다/습니다).

잡음 제거. "um/uh", 반복·말꼬리 등 비의미적 군더더기는 삭제합니다. [laughter], [music] 등 비언어 표기는 무시합니다.

분절/길이. 입력 덩어리마다 정보 순서를 유지해 1–2개 문장(또는 불릿)으로 간결히 냅니다. 입력이 목록이면 줄바꿈으로 대응합니다.

보존 대상(그대로 두기). 코드, CLI 명령, 함수/메서드명, 파일/패키지명, 지갑 주소, 트랜잭션 해시, 키/시크릿, 에러코드, 버전/프로토콜명, 링크·URL, 토큰 심볼은 원문 그대로.

숫자/단위/기호. 수치·%·통화·시간·버전은 정확히 보존합니다. "$5 million"→500만 달러, 30%는 그대로 유지.

정책 준수. 안전 정책상 불가한 입력은 번역을 중단할 수 있으나, 그 외에는 번역 외 결과물 생성 금지(요약/정리/하이라이트/제목/Q&A/테이블 등 일절 금지).

언어 판별 규칙

1. 한국어가 주 언어인 경우 → 영어로 번역
2. 영어가 주 언어인 경우 → 한국어로 번역
3. 한영 혼용 (코드스위칭) → 전체 의미를 살려 반대 언어로 번역
4. 고유명사, 기술 용어는 관용 표현 사용

도메인 용어 정책

공통(영문 유지 권장): 체인/토큰/기업·제품명, 토큰 심볼, API/SDK, EVM/L1/L2, zk‑SNARK/zk‑STARK, MEV, IPFS, WASM, TEE, 알고리즘·함수명, 라이브러리/패키지명, SAFE/KISS, KPI/OKR, ARR/MRR, CAC/LTV, TAM/SAM/SOM, DAU/MAU, A/B test, GTM, churn, runway, burn rate, dilution, cap table, pro rata, vesting/cliff, pre/post‑money, term sheet, liquidation preference 등은 약어·형태를 보존합니다. (원문에 풀어쓴 경우에만 그 부분은 번역)

권장 한글화(관용 표기):

블록체인: blockchain→블록체인, smart contract→스마트 컨트랙트, rollup→롤업, mainnet/testnet→메인넷/테스트넷, gas fee→가스비, tokenomics→토크노믹스, governance→거버넌스, staking/slashing→스테이킹/슬래싱, proof of stake/work→지분증명/작업증명, validator→검증인.

스타트업: product‑market fit→제품‑시장 적합성, cohort→코호트, retention→리텐션, funnel→퍼널, conversion rate→전환율, unit economics→유닛 이코노믹스, board→이사회, pivot→피벗.

의미 변경 금지. 고유명사는 번역하지 않고 음역도 지양(필요 시 원문 병기 없이 그대로 둠).

## 입력/출력 제약
- 입력: 한국어 또는 영어 텍스트
- 출력: 반대 언어로 번역된 텍스트만 (다른 모든 텍스트 금지)
- 금지사항:
  * 대화, 질문, 응답, 설명, 주석, 해설 절대 금지
  * "번역:", 따옴표, 이모지, 메타텍스트 절대 금지
  * "안녕하세요", "도움이 되셨기를", "감사합니다" 등 인사말 절대 금지
  * 한국어/영어가 아닌 입력에는 완전 빈 응답("")만 반환

## 출력 형식 강제
- 번역문만 출력
- 번역문이 없으면 빈 문자열("")
- 추가 설명, 주석, 대화 시도 시 즉시 세션 종료

## 번역 품질 규칙
- 전문 컨퍼런스 수준의 정확한 번역
- 블록체인/웹3/스타트업 용어는 관용 표현 사용
- 기술 용어, 코드, 숫자는 적절히 처리
- 자연스러운 문체 (한국어: ~합니다/습니다, 영어: 자연스러운 표현)

예시:
입력 (영어): "Hello, how are you?"
출력: 안녕하세요, 어떻게 지내세요?

입력 (한국어): "안녕하세요, 잘 지내시나요?"
출력: Hello, how are you?

입력 (영어): "We're launching our DeFi protocol next quarter"
출력: 다음 분기에 DeFi 프로토콜을 출시할 예정입니다

입력 (한국어): "우리는 블록체인 기반 DeFi 프로토콜을 개발합니다"
출력: We develop blockchain-based DeFi protocols

입력 (한영 혼용): "우리 startup이 Web3 market에 진입합니다"
출력: Our startup is entering the Web3 market

이 지침을 엄격히 준수하여 번역만 수행하세요.`;
  }

  // 자막 지우기
  // 🚫 자막 지우기 버튼 이벤트 리스너 제거
  // if (btnClear) { ... } ← 삭제

  // 실시간으로 버튼
  if (backToLiveBtn) {
    backToLiveBtn.onclick = () => {
      console.log('🎯 Back to live clicked - enabling auto scroll');
      isUserScrolling = false;
      autoScrollToBottom();
    };
  }

  // Utility functions
  function logStatus(status, className = '') {
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.className = `status-chip ${className}`;
    }
  }

  function logLatency(ms) {
    if (latencyEl) {
      if (ms > 0) {
        latencyEl.style.display = 'block';
        latencyEl.textContent = `${Math.round(ms)}ms`;
      } else {
        latencyEl.style.display = 'none';
      }
    }
  }

  // 토스트 메시지
  function showToast(message, type = 'info') {
    if (type === 'error' || type === 'warning') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 24px; left: 50%;
        transform: translateX(-50%);
        background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
        color: white; padding: 16px 24px; border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 1002; font-size: 14px; font-weight: 500;
        opacity: 0; transition: opacity 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.style.opacity = '1', 10);
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }
  }

  // 🎨 타이핑 번역 함수들
  function startTypingTranslation() {
    if (currentTypingLine) {
      currentTypingLine.remove();
    }
    currentTypingLine = document.createElement('div');
    currentTypingLine.className = 'caption-line typing fade-in';
    currentTypingLine.textContent = '';
    captionContainer.appendChild(currentTypingLine);

    // 🎯 사용자 스크롤 상태 확인 후 자동 스크롤
    autoScrollToBottom();
  }

  function updateTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.textContent = text;
    }
  }

  function completeTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.className = 'caption-line stable fade-in';
      currentTypingLine.textContent = text;
      currentTypingLine = null;
    }
  }

  // 자막 추가 함수
  function appendLine(text, className = 'stable') {
    if (!text || !text.trim()) return;

    const welcomeState = captionContainer.querySelector('.welcome-state');
    if (welcomeState) {
      welcomeState.remove();
    }

    if (className === 'unstable') {
      if (!currentUnstableLine) {
        currentUnstableLine = document.createElement('div');
        currentUnstableLine.className = `caption-line ${className}`;
        currentUnstableLine.textContent = '';
        captionContainer.appendChild(currentUnstableLine);
      }
      const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
      currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className} fade-in`;
      div.textContent = text.trim();
      captionContainer.appendChild(div);
    }

    // 🎯 사용자가 스크롤 중이 아닐 때만 자동 스크롤
    autoScrollToBottom();

    // 자막 히스토리 관리
    const captionLines = captionContainer.querySelectorAll('.caption-line');
    if (captionLines.length > 100) {
      captionLines[0].remove();
    }
  }

  // 🎯 개선된 스크롤 상태 관리
  function updateScrollState() {
    const scrollTop = viewer.scrollTop;
    const scrollHeight = viewer.scrollHeight;
    const clientHeight = viewer.clientHeight;
    const isAtBottom = scrollTop >= (scrollHeight - clientHeight - 50);

    console.log('📊 스크롤 상태:', { scrollTop, scrollHeight, clientHeight, isAtBottom });

    // 맨 아래 근처에 있으면 자동 스크롤 모드
    if (isAtBottom) {
      isUserScrolling = false;
    }

    // 실시간으로 버튼 표시/숨김 (개선된 로직)
    if (backToLiveBtn) {
      const now = Date.now();

      // 🔧 최근 자동 스크롤 직후에는 버튼 표시 안함
      if (now - lastAutoScrollTime < 1000) {  // 1초간 버튼 숨김
        backToLiveBtn.style.display = 'none';
        return;
      }

      if (!isAtBottom && isUserScrolling) {
        backToLiveBtn.style.display = 'flex';
      } else {
        backToLiveBtn.style.display = 'none';
      }
    }
  }

  // 🎯 사용자 스크롤 감지 (터치/마우스 이벤트)
  let scrollTimer = null;
  viewer.addEventListener('scroll', (e) => {
    const now = Date.now();

    // 🔧 최근 자동 스크롤이 아닌 경우에만 사용자 스크롤로 간주
    if (now - lastAutoScrollTime > 800) {  // 800ms로 여유 확대
      isUserScrolling = true;
      console.log('🔄 User scrolling detected - auto scroll disabled');
    }

    // 🔧 스크롤 끝난 후 상태 업데이트 (딜레이 증가)
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => {
      updateScrollState();
    }, 250);  // 250ms로 딜레이 증가
  });

  // 🎯 자동 스크롤 함수 (margin-top 고려)
  function autoScrollToBottom() {
    if (!isUserScrolling) {
      lastAutoScrollTime = Date.now();  // 자동 스크롤 시간 기록

      // 🔧 DOM 업데이트 완료 후 스크롤 실행
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {  // 이중 RAF로 DOM 안정화 대기
          // margin-top을 고려한 스크롤 높이 계산
          const scrollHeight = Math.max(viewer.scrollHeight, captionContainer.scrollHeight);
          viewer.scrollTo({
            top: scrollHeight,
            behavior: 'smooth'
          });
          console.log('🔽 Auto scroll triggered, scrollHeight:', scrollHeight);

          // 🔧 스크롤 완료 후 상태 업데이트 (딜레이 추가)
          setTimeout(() => {
            if (!isUserScrolling) {  // 여전히 자동 모드면
              updateScrollState();
            }
          }, 200);  // 스크롤 애니메이션 완료 대기
        });
      });
    } else {
      console.log('⏸️ Auto scroll skipped - user is scrolling');
    }
  }

  function clearViewer() {
    captionContainer.innerHTML = `
      <div class="welcome-state">
        <div class="icon">🎙️</div>
        <h1>실시간 한영 자막</h1>
        <p>한국어와 영어로 말하면<br>실시간 자막과 번역이 나타납니다</p>
        <div class="hint">
          <span>⚙️</span>
          <span>우상단 설정에서 마이크를 활성화하세요</span>
        </div>
        <div style="margin-top: 16px; font-size: 14px; color: rgba(255, 255, 255, 0.5);">
          <div>🔄 번역 규칙:</div>
          <div>• 한국어 → 영어</div>
          <div>• 영어 → 한국어</div>
        </div>
      </div>
    `;
    currentUnstableLine = null;
    currentTypingLine = null;
    if (backToLiveBtn) {
      backToLiveBtn.style.display = 'none';
    }
  }

  function displayTranscriptAndTranslation(transcript, translation) {
    // 원문 표시
    appendLine(transcript, 'original');

    // 번역 표시 (완성된 경우만)
    if (translation &&
        !translation.includes('[번역') &&
        !translation.includes('[오류') &&
        translation.trim().length > 0) {
      completeTypingTranslation(translation);
    }
  }

  // Permission and device handling
  async function ensurePermission() {
    try {
      logStatus('권한 요청 중', 'connecting');

      const permissionStatus = await navigator.permissions.query({name: 'microphone'});
      if (permissionStatus.state === 'denied') {
        throw new Error('마이크 권한이 차단되었습니다.');
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 16000  // ⚡ AudioContext와 일치시켜 리샘플링 오버헤드 제거
        }
      });

      stream.getTracks().forEach(track => track.stop());
      logStatus('권한 허용됨', 'connected');
      return true;
    } catch (error) {
      logStatus('권한 필요', 'error');
      showToast('마이크 권한이 필요합니다', 'warning');
      return false;
    }
  }

  async function listMics() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      if (selMic) {
        selMic.innerHTML = '<option value="">마이크를 선택하세요</option>';

        if (audioInputs.length === 0) {
          selMic.innerHTML = '<option value="">마이크를 찾을 수 없습니다</option>';
          return;
        }

        audioInputs.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `마이크 ${index + 1}`;
          selMic.appendChild(option);
        });

        if (!currentDeviceId && audioInputs.length > 0) {
          const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
          currentDeviceId = defaultDevice.deviceId;
          selMic.value = currentDeviceId;
        }

        selMic.disabled = false;
      }
    } catch (error) {
      showToast('장치 목록을 가져올 수 없습니다', 'error');
    }
  }

  async function getStream(deviceId) {
    try {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      const constraints = {
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 16000,  // ⚡ AudioContext와 일치
          channelCount: 1
        }
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      currentDeviceId = deviceId;
      return localStream;
    } catch (error) {
      throw new Error('오디오 스트림을 가져올 수 없습니다.');
    }
  }

  // OpenAI Realtime API 연결 초기화

  // OpenAI 세션 데이터 가져오기 (bootstrap에서)
  function getOpenAISession() {
    if (!BOOT.openai_session) {
      throw new Error('OpenAI 세션이 없습니다. 시작 버튼을 눌러주세요.');
    }
    console.log('✅ OpenAI 세션 로드:', BOOT.openai_session);
    return BOOT.openai_session;
  }

  async function initializeOpenAIConnection() {
    try {
      openaiSession = getOpenAISession();

      // RTCPeerConnection 설정
      peerConnection = new RTCPeerConnection();

      // DataChannel 생성 - OpenAI 메시지용
      dataChannel = peerConnection.createDataChannel('oai-events', {
        ordered: true
      });

      dataChannel.onopen = () => {
        console.log('✅ DataChannel 연결됨');

        // Session instructions 전송
        const sessionUpdate = {
          type: 'session.update',
          session: {
            input_audio_format: 'pcm16',
            input_audio_transcription: {
              model: 'gpt-4o-transcribe',
            },
            turn_detection: {
              type: 'server_vad',
              threshold: 0.5,
              prefix_padding_ms: 300,
              silence_duration_ms: 500
            }
          }
        };

        dataChannel.send(JSON.stringify(sessionUpdate));
        console.log('📤 Transcription-only session 설정됨');
      };

      dataChannel.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleOpenAIMessage(message);
        } catch (error) {
          console.error('❌ DataChannel 메시지 파싱 오류:', error);
        }
      };

      dataChannel.onerror = (error) => {
        console.error('❌ DataChannel 오류:', error);
      };

      dataChannel.onclose = () => {
        console.log('🔌 DataChannel 연결 종료');
      };

      // WebSocket 연결 (app.py의 OpenAI handler와 통신용)
      // ALB 경로 기반 라우팅 사용: /ws 경로로 연결
      let hostname = window.location.hostname;

      // about:srcdoc 환경에서는 부모 창의 hostname 사용
      if (!hostname || hostname === '' || window.location.href.startsWith('about:')) {
        try {
          hostname = window.parent.location.hostname;
        } catch (e) {
          // Cross-origin 제한시 기본값 사용
          hostname = 'localhost';
        }
      }

      // 현재 페이지 프로토콜에 맞춰 WebSocket 프로토콜 결정
      const isHTTPS = window.location.protocol === 'https:' ||
                      (window.parent && window.parent.location.protocol === 'https:');

      const wsProtocol = isHTTPS ? 'wss:' : 'ws:';

      // ALB 경로 기반 라우팅: 포트 없이 /ws 경로 사용
      const wsUrl = hostname === 'localhost'
        ? `${wsProtocol}//localhost:${BOOT.websocket_port || 8765}` // 로컬 개발
        : `${wsProtocol}//${hostname}/ws`; // 배포 환경

      console.log(`🔗 WebSocket 연결 시도: ${wsUrl} (HTTPS: ${isHTTPS})`);

      openaiWebSocket = new WebSocket(wsUrl);

      openaiWebSocket.onopen = () => {
        console.log(`✅ OpenAI WebSocket 연결됨: ${wsUrl}`);
      };

      openaiWebSocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleTranslationMessage(data);
        } catch (error) {
          console.error('❌ WebSocket 메시지 파싱 오류:', error);
        }
      };

      openaiWebSocket.onerror = (error) => {
        console.error(`❌ OpenAI WebSocket 오류 (${wsUrl}):`, error);
      };

      openaiWebSocket.onclose = (event) => {
        console.log(`🔌 OpenAI WebSocket 연결 종료 (${wsUrl}): Code ${event.code}`);
      };

      return true;
    } catch (error) {
      console.error('❌ OpenAI 연결 초기화 실패:', error);
      throw error;
    }
  }

  // OpenAI Realtime API 메시지 처리
  function handleOpenAIMessage(message) {
    console.log('[OpenAI] 메시지 수신:', message);

    switch (message.type) {
      case 'session.created':
        console.log('✅ OpenAI 세션 생성됨');
        logStatus('🎤 음성 인식 중', 'connected');
        break;

      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();
          console.log('[OpenAI Transcript]', transcript);

          // 원문 표시 (언어 표기 제거)
          appendLine(transcript, 'original');

          // WebSocket을 통해 app.py로 번역 요청 전송
          if (openaiWebSocket && openaiWebSocket.readyState === WebSocket.OPEN) {
            openaiWebSocket.send(JSON.stringify({
              type: 'transcript',
              text: transcript,
              timestamp: Date.now()
            }));
          }
        }
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('음성 감지됨', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('음성 처리 중', 'connecting');
        break;

      case 'error':
        console.error('[OpenAI] 오류:', message.error);
        logStatus('오류', 'error');
        showToast(`OpenAI 오류: ${message.error.message || message.error}`, 'error');
        break;

      default:
        console.log('[OpenAI Unhandled]', message.type);
        break;
    }
  }

  // 번역 결과 처리 (app.py WebSocket에서)
  function handleTranslationMessage(data) {
    console.log('[Translation] 메시지 수신:', data);

    switch (data.type) {
      case 'transcription_result':
        // 번역된 텍스트가 있으면 표시
        if (data.translated_text && data.translated_text !== data.original_text) {
          startTypingTranslation();
          // 즉시 번역 완료 표시
          setTimeout(() => {
            completeTypingTranslation(data.translated_text);
          }, 100);
        }
        break;

      case 'connection':
        console.log('[Translation] 연결 상태:', data.status);
        break;

      case 'error':
        console.error('[Translation] 오류:', data.message);
        showToast(`번역 오류: ${data.message}`, 'error');
        if (currentTypingLine) {
          currentTypingLine.remove();
          currentTypingLine = null;
        }
        break;

      default:
        console.log('[Translation] 알 수 없는 메시지 타입:', data.type);
        break;
    }
  }

  // OpenAI Realtime API 연결 (WebRTC)
  async function connectOpenAIRealtime() {
    try {
      logStatus('연결 중', 'connecting');
      startTime = Date.now();

      await initializeOpenAIConnection();

      if (!localStream && currentDeviceId) {
        localStream = await getStream(currentDeviceId);
      } else if (!localStream) {
        throw new Error('마이크가 선택되지 않았습니다.');
      }

      // 오디오 트랙을 RTCPeerConnection에 추가
      localStream.getAudioTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
      });

      // SDP Offer 생성
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      console.log('📤 SDP Offer 생성됨');

      // OpenAI Realtime API에 연결 요청
      const response = await fetch(`https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${openaiSession.client_secret}`,
          'Content-Type': 'application/sdp'
        },
        body: offer.sdp
      });

      if (!response.ok) {
        throw new Error(`OpenAI API 요청 실패: ${response.status}`);
      }

      const answerSdp = await response.text();
      console.log('📥 SDP Answer 수신됨');

      const answer = {
        type: 'answer',
        sdp: answerSdp
      };

      await peerConnection.setRemoteDescription(answer);
      console.log('✅ OpenAI WebRTC 연결 완료');

      logStatus('🎤 음성 인식 중', 'connected');

    } catch (error) {
      console.error('❌ OpenAI 연결 실패:', error);
      logStatus('연결 실패', 'error');
      showToast(error.message || 'OpenAI 연결에 실패했습니다', 'error');
      closeConnection();
      throw error;
    }
  }

  // AWS 서버 연결 (레거시 - 사용 안함)
  function initializeAWSConnection() {

    if (!BOOT.aws_session) {
      const error = 'BOOT.aws_session이 없습니다.';
      console.error('❌', error);
      throw new Error(error);
    }

    let wsUrl = BOOT.aws_session.websocket_url;

    if (!wsUrl) {
      const region = BOOT.aws_session.region || 'us-east-1';
      wsUrl = `wss://transcribestreaming.${region}.amazonaws.com:8443/stream-transcription-websocket`;
      console.log('⚠️ websocket_url이 없어서 기본 URL 생성:', wsUrl);
    }

    return new Promise((resolve, reject) => {
      console.log('🔗 WebSocket 연결 시도:', wsUrl);

      try {
        awsWebSocket = new WebSocket(wsUrl);

        // 🔍 연결 상태 상세 모니터링
        let messageCount = 0;
        let lastHeartbeat = Date.now();

        const connectionTimeout = setTimeout(() => {
          if (awsWebSocket.readyState === WebSocket.CONNECTING) {
            console.error('❌ WebSocket 연결 타임아웃');
            awsWebSocket.close();
            reject(new Error('WebSocket 연결 타임아웃'));
          }
        }, 10000);

        awsWebSocket.onopen = () => {
          clearTimeout(connectionTimeout);
          console.log('✅ [AWS WebSocket] 연결 성공');


          resolve(true);
        };

        awsWebSocket.onmessage = (event) => {
          messageCount++;
          lastHeartbeat = Date.now();

          try {
            const data = JSON.parse(event.data);
            handleAWSMessage(data);
          } catch (error) {
            console.error('❌ [AWS WebSocket] JSON 파싱 오류:', error);
          }
        };

        awsWebSocket.onerror = (error) => {
          clearTimeout(connectionTimeout);
          console.error('❌ [AWS WebSocket] 오류:', error);
          reject(error);
        };

        awsWebSocket.onclose = (event) => {
          clearTimeout(connectionTimeout);
          console.log('🔌 [AWS WebSocket] 연결 종료');
          awsWebSocket = null;
        };

      } catch (error) {
        console.error('❌ WebSocket 생성 오류:', error);
        reject(error);
      }
    });
  }

  // AWS 메시지 처리
  function handleAWSMessage(data) {
    console.log('[AWS] 메시지 수신:', data);

    switch (data.type) {
      case 'connection':
        logStatus('AWS 연결됨 (다중언어+LLM)', 'connected');
        break;

      case 'transcription_partial':
        // 실시간 transcription (부분)
        if (!currentUnstableLine) {
          appendLine(`[인식중] ${data.transcript}`, 'unstable');
        } else {
          currentUnstableLine.textContent = `[인식중] ${data.transcript}`;
        }
        break;

      case 'transcription_result':
        // 새로운 다중언어 + 번역 결과 처리
        if (currentUnstableLine) {
          currentUnstableLine.remove();
          currentUnstableLine = null;
        }

        // 원본 텍스트 표시 (언어 정보 포함)
        const sourceLanguageName = getLanguageName(data.source_language);
        appendLine(`${data.original_text} (${sourceLanguageName})`, 'original');

        // 번역된 텍스트가 있다면 타이핑 애니메이션으로 표시
        if (data.translated_text && data.translated_text !== data.original_text) {
          const targetLanguageName = getLanguageName(data.target_language);
          startTypingTranslation();
          // ⚡ 애니메이션 딜레이 제거 - 즉시 표시
          completeTypingTranslation(`${data.translated_text}`);
        }
        break;

      case 'translation_result':
        // 직접 번역 요청 결과 (기존 호환성 유지)
        if (data.translated_text) {
          startTypingTranslation();
          // ⚡ 애니메이션 딜레이 제거 - 즉시 표시
          completeTypingTranslation(data.translated_text);
        }
        break;

      case 'error':
        console.error('[AWS] 오류:', data.message);
        showToast(`AWS 오류: ${data.message}`, 'error');
        appendLine(`❌ 오류: ${data.message}`, 'original');
        break;
    }
  }

  // 언어 코드를 한국어 이름으로 변환
  function getLanguageName(languageCode) {
    const languageNames = {
      'en-US': '영어',
      'en': '영어',
      'ko-KR': '한국어',
      'ko': '한국어',
      'zh-CN': '중국어',
      'zh': '중국어',
      'ja-JP': '일본어',
      'ja': '일본어',
      'es': '스페인어',
      'fr': '프랑스어',
      'de': '독일어'
    };
    return languageNames[languageCode] || languageCode;
  }


  // AWS Transcribe 직접 연결 (오디오 스트리밍)
  let audioContext = null;
  let audioWorklet = null;
  let mediaStream = null;
  let isTranscriptionActive = false;


  async function connectAWSTranscribe() {
    try {
      logStatus('연결 중', 'connecting');
      startTime = Date.now();

      await initializeAWSConnection();
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate: 16000
        });
      }

      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }

      if (!mediaStream && currentDeviceId) {
        mediaStream = await getStream(currentDeviceId);
      } else if (!mediaStream) {
        throw new Error('마이크가 선택되지 않았습니다.');
      }

      // 🔍 디버깅이 강화된 AudioWorkletProcessor
      const audioWorkletCode = `
        class AudioProcessor extends AudioWorkletProcessor {
          constructor() {
            super();
            this.bufferSize = 1024;  // ⚡ 더 작은 버퍼로 지연시간 단축 (64ms)
            this.buffer = new Float32Array(this.bufferSize);
            this.bufferIndex = 0;
            this.chunkCount = 0;
            this.lastLogTime = 0;
            this.totalSamples = 0;
            this.maxVolume = 0;
          }

          process(inputs) {
            const input = inputs[0];
            if (input.length > 0 && input[0]) {
              const audioData = input[0];
              this.totalSamples += audioData.length;

              // 볼륨 체크
              let chunkMax = 0;
              for (let i = 0; i < audioData.length; i++) {
                const sample = Math.abs(audioData[i]);
                if (sample > chunkMax) chunkMax = sample;
                if (sample > this.maxVolume) this.maxVolume = sample;

                this.buffer[this.bufferIndex] = audioData[i];
                this.bufferIndex++;

                if (this.bufferIndex >= this.bufferSize) {
                  this.chunkCount++;

                  // PCM 변환
                  const pcmBuffer = new ArrayBuffer(this.bufferSize * 2);
                  const pcmView = new DataView(pcmBuffer);

                  for (let j = 0; j < this.bufferSize; j++) {
                    const sample = Math.max(-1, Math.min(1, this.buffer[j]));
                    const pcmSample = Math.round(sample * 32767);
                    pcmView.setInt16(j * 2, pcmSample, true);
                  }

                  this.port.postMessage({
                    type: 'audio',
                    data: pcmBuffer,
                    chunkId: this.chunkCount,
                    maxVolume: chunkMax,
                    sampleRate: 16000,
                    channels: 1
                  });

                  this.bufferIndex = 0;
                }
              }

            }
            return true;
          }
        }
        registerProcessor('audio-processor', AudioProcessor);
      `;

      const blob = new Blob([audioWorkletCode], { type: 'application/javascript' });
      const workletUrl = URL.createObjectURL(blob);
      await audioContext.audioWorklet.addModule(workletUrl);

      audioWorklet = new AudioWorkletNode(audioContext, 'audio-processor');

      audioWorklet.port.onmessage = (event) => {
        if (event.data.type === 'audio') {
          const now = Date.now();
          const { data: audioBuffer, chunkId, maxVolume } = event.data;
          const dataSize = audioBuffer.byteLength;

          // 음성 감지 (기존 로직 유지)
          const isSpeech = maxVolume > 0.05;

          if (!window.speechState) {
            window.speechState = {
              isDetected: false,
              lastDetectionTime: 0,
              consecutiveSpeech: 0,
              lastDisplayTime: 0
            };
          }

          if (isSpeech) {
            window.speechState.consecutiveSpeech++;

            if (!window.speechState.isDetected) {
              window.speechState.isDetected = true;
            }

            window.speechState.lastDetectionTime = now;
          } else {
            if (window.speechState.isDetected && (now - window.speechState.lastDetectionTime > 3000)) {
              window.speechState.isDetected = false;
              window.speechState.consecutiveSpeech = 0;
            }
          }

          // AWS로 데이터 전송
          if (awsWebSocket && awsWebSocket.readyState === WebSocket.OPEN && isTranscriptionActive) {
            try {
              // ⚡ 더 효율적인 Base64 인코딩 방식
              const uint8Array = new Uint8Array(audioBuffer);
              let binary = '';
              const chunkSize = 8192; // 8KB 청크로 처리하여 스택 오버플로우 방지
              for (let i = 0; i < uint8Array.length; i += chunkSize) {
                const chunk = uint8Array.subarray(i, i + chunkSize);
                binary += String.fromCharCode.apply(null, chunk);
              }
              const base64Audio = btoa(binary);

              const message = {
                type: 'audio_chunk',
                audio: base64Audio,
                format: 'pcm',
                sample_rate: 16000,
                channels: 1,
                bytes_per_sample: 2,
                timestamp: now,
                chunk_id: chunkId,
                data_size: dataSize,
                max_volume: maxVolume
              };

              awsWebSocket.send(JSON.stringify(message));

            } catch (error) {
              console.error('❌ [WebSocket] 전송 오류:', error);
            }
        }
        }
      };

      const source = audioContext.createMediaStreamSource(mediaStream);
      source.connect(audioWorklet);

      isTranscriptionActive = true;
      logStatus('🎤 음성 인식 중', 'connected');

    } catch (error) {
      console.error('❌ 연결 실패:', error);
      logStatus('연결 실패', 'error');
      showToast(error.message || '연결에 실패했습니다', 'error');
      closeConnection();
      throw error;
    }
  }


  // 번역 요청 스마트 필터링 함수
  function shouldRequestTranslation(transcript) {
    const now = Date.now();

    // 1. 이미 번역 진행 중이면 스킵
    if (responseInProgress) {
      console.log('[Skip Translation] Already in progress');
      return false;
    }

    // 2. 같은 내용 또는 매우 유사한 내용이면 스킵
    if (lastTranslationRequest === transcript) {
      console.log('[Skip Translation] Duplicate request');
      return false;
    }

    // 3. 이전 요청이 부분 문자열인경우 스킵 (확장된 내용)
    if (lastTranslationRequest && transcript.startsWith(lastTranslationRequest) &&
        transcript.length - lastTranslationRequest.length < 10) {
      console.log('[Skip Translation] Minor extension of previous request');
      return false;
    }

    // 4. 너무 빠른 연속 요청 방지 (디바운싱)
    if (now - translationRequestTime < 1000) { // 1초 간격
      console.log('[Skip Translation] Too frequent requests');
      return false;
    }

    return true;
  }

  // 영어 문장 완성도 체크 함수 추가
  function isTranscriptComplete(transcript) {
    // 최소 길이 체크 (영어는 3글자 이상)
    if (transcript.length < 3) {
      return false;
    }

    // 문장 부호로 끝나면 완성된 것으로 간주
    if (/[.!?]$/.test(transcript)) {
      return true;
    }

    // 단어가 완전히 끝났는지 체크 (공백이나 구두점 뒤 완전한 단어)
    const words = transcript.split(/\s+/);
    const lastWord = words[words.length - 1];

    // 마지막 단어가 너무 짧으면 불완전할 가능성
    if (lastWord.length < 2) {
      return false;
    }

    // 일반적인 불완전 단어 패턴들
    const incompletePatterns = [
      /ing$/,  // -ing로 끝나는 경우는 대부분 완성
      /ed$/,   // -ed로 끝나는 경우도 완성
      /[aeiou]$/,  // 모음으로 끝나면 보통 완성
      /[bcdfghjklmnpqrstvwxyz]{2,}$/  // 자음 2개 이상으로 끝나면 보통 완성
    ];

    // 패턴 매칭으로 완성도 판단
    return incompletePatterns.some(pattern => pattern.test(lastWord.toLowerCase()));
  }

  function handleRealtimeMessage(message) {
    if (isPaused && !message.type?.includes('error')) {
      return;
    }


    // 지연시간 측정
    if (startTime && latencyEl && !latencyEl.textContent) {
      const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
        (message.delta || message.text || message.transcript);
      if (isContent) {
        const latency = Date.now() - startTime;
        logLatency(latency);
        startTime = null;
      }
    }

    switch (message.type) {
      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();

          // 영어 문장 완성도 체크 개선
          const isComplete = isTranscriptComplete(transcript);
          const isDuplicate = transcript === lastProcessedTranscript ||
                            (lastProcessedTranscript && transcript.length > 5 &&
                             lastProcessedTranscript.includes(transcript.slice(0, -2)));

          if (!isComplete || isDuplicate) {
            console.log('[Skip] Incomplete or duplicate:', transcript, { isComplete, isDuplicate });
            break;
          }

          lastProcessedTranscript = transcript;
          console.log('[Transcription] New:', transcript);

          // 이전 pending 완료
          if (pendingTranscript && pendingTranscript !== transcript) {
            if (pendingTranslation) {
              completeTypingTranslation(pendingTranslation);
            } else if (currentTypingLine) {
              currentTypingLine.remove();
              currentTypingLine = null;
            }
          }

          // 🎨 원문 즉시 표시
          appendLine(transcript, 'original');

          // 🎨 빈 타이핑 말풍선 생성
          startTypingTranslation();

          pendingTranscript = transcript;
          pendingTranslation = '';

          // 🚀 스마트 필터링으로 불필요한 번역 요청 방지
          if (dc && dc.readyState === 'open' && shouldRequestTranslation(transcript)) {
            responseInProgress = true;
            lastTranslationRequest = transcript;
            translationRequestTime = Date.now();

            dc.send(JSON.stringify({ type: 'response.create' }));
            console.log('[Translation] ✅ Requested for:', transcript);

            setTimeout(() => {
              if (responseInProgress && pendingTranscript === transcript) {
                console.warn('[Translation] ⏱️ Timeout for:', transcript);
                responseInProgress = false;
                currentResponseId = null;
                if (currentTypingLine) {
                  currentTypingLine.remove();
                  currentTypingLine = null;
                }
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }, 2500);
          } else if (dc && dc.readyState === 'open') {
            // 번역 요청을 스킵했지만 원문은 표시했으므로 상태 정리
            console.log('[Translation] 🚫 Skipped request for:', transcript);
            pendingTranscript = null;
            pendingTranslation = '';
          }
        }
        break;

      case 'response.text.delta':
        if (message.delta && pendingTranscript) {
          const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
          if (!cleanDelta.toLowerCase().includes('cannot') &&
              !cleanDelta.toLowerCase().includes('sorry')) {
            pendingTranslation += cleanDelta;

            // 🎨 실시간 타이핑 업데이트
            updateTypingTranslation(pendingTranslation);
            console.log('[Delta]', cleanDelta);
          }
        }
        break;

      case 'response.text.done':
        if (message.text && pendingTranscript) {
          let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
          console.log('[Done]', cleanText);

          // 🚫 거부 메시지들 필터링 강화
          if (cleanText.toLowerCase().includes('cannot assist') ||
              cleanText.toLowerCase().includes('sorry, but i can\'t') ||
              cleanText.toLowerCase().includes('죄송합니다') ||
              cleanText.toLowerCase().includes('응답할 수 없습니다') ||
              cleanText.toLowerCase().includes('해당 요청') ||
              cleanText.length === 0) {
            cleanText = '';
          }

          const finalTranslation = cleanText || pendingTranslation.trim();
          console.log('[Final Translation]', finalTranslation);

          if (finalTranslation && finalTranslation.length > 0) {
            // 🎨 타이핑 완료 - 초록색 테두리로 변경
            completeTypingTranslation(finalTranslation);
          } else if (currentTypingLine) {
            // 번역 실패 시 타이핑 라인 제거
            currentTypingLine.remove();
            currentTypingLine = null;
          }

          pendingTranscript = null;
          pendingTranslation = '';
        }
        break;

      case 'response.created':
        currentResponseId = message.response?.id || Date.now().toString();
        responseInProgress = true;
        console.log('[Response] Created:', currentResponseId);
        break;

      case 'response.done':
        responseInProgress = false;
        currentResponseId = null;
        console.log('[Response] Done');
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('음성 인식 중', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('처리 중', 'connecting');
        break;

      case 'error':
        console.error('[Error]', message.error);
        logStatus('오류', 'error');
        showToast('서비스 오류가 발생했습니다', 'error');
        break;

      default:
        console.log('[Unhandled]', message.type);
        break;
    }
  }

  function closeConnection() {
    try {
      // AWS WebSocket 연결 해제
      if (awsWebSocket) {
        awsWebSocket.close();
        awsWebSocket = null;
      }

      // 음성 인식 중단
      stopSpeechRecognition();

      // 오디오 스트림 정리
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      // 상태 초기화
      currentUnstableLine = null;
      currentTypingLine = null;
      responseInProgress = false;
      currentResponseId = null;
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      lastTranslationRequest = null;
      translationRequestTime = 0;
      isPaused = false;
      isUserScrolling = false;
      lastAutoScrollTime = 0;

      logStatus('대기중', '');
      logLatency(0);
      if (backToLiveBtn) {
        backToLiveBtn.style.display = 'none';
      }

      console.log('[AWS] Connection closed and resources cleaned up');
    } catch (error) {
      console.error('Close connection error:', error);
    }
  }

  // Event handlers
  if (btnPerm) {
    btnPerm.onclick = async () => {
      const success = await ensurePermission();
      if (success) {
        await listMics();
      }
    };
  }

  // 🚫 일시정지 버튼 이벤트 리스너 제거
  // if (btnPause) { ... } ← 삭제

  if (selMic) {
    selMic.onchange = async (event) => {
      const newDeviceId = event.target.value;
      if (!newDeviceId) return;

      const wasConnected = peerConnection && peerConnection.connectionState === 'connected';
      currentDeviceId = newDeviceId;

      if (wasConnected) {
        try {
          logStatus('장치 변경 중', 'connecting');
          closeConnection();

          // 새 오디오 스트림 준비
          const newStream = await getStream(newDeviceId);

          // OpenAI 연결 재시작
          setTimeout(async () => {
            try {
              await connectOpenAIRealtime();
            logStatus('연결됨', 'connected');
            } catch (error) {
              logStatus('장치 변경 실패', 'error');
              selMic.value = currentDeviceId;
          }
          }, 1000);

        } catch (error) {
          logStatus('장치 변경 실패', 'error');
          selMic.value = currentDeviceId;
        }
      }
    };
  }


  (async () => {
    try {
      console.log('Bootstrap starting...', BOOT);

      if (BOOT.action === 'start' && BOOT.openai_session) {
        const hasPermission = await ensurePermission();
        if (hasPermission) {
          await listMics();
          await connectOpenAIRealtime();
        }
      } else if (BOOT.action === 'stop') {
        closeConnection();
        clearViewer();
      } else {
        logStatus('대기중', '');
      }

      console.log('Bootstrap completed successfully');
    } catch (error) {
      console.error('Bootstrap error:', error);
      logStatus('초기화 실패', 'error');
      showToast(`초기화 오류: ${error.message}`, 'error');
    }
  })();

  // Cleanup
  window.addEventListener('beforeunload', () => {
    closeConnection();
  });

} catch (globalError) {
  console.error('Global script error:', globalError);
  document.getElementById('status').textContent = '스크립트 오류';
  document.getElementById('status').className = 'status-chip error';
}
</script>
</body>
</html>
