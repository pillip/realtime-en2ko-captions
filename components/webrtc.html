<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
    }

    /* 플로팅 설정 버튼 */
    .settings-fab {
      position: fixed;
      top: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* 설정 패널 */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* 상태 표시 */
    .status-overlay {
      position: fixed;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* 실시간으로 버튼 - 상태바와 같은 높이 */
    .back-to-live {
      position: fixed;
      bottom: 32px;  /* 상태바와 같은 높이 */
      right: 32px;   /* 오른쪽에 배치 */
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(16, 185, 129, 0.4);
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    /* 메인 캡션 뷰어 */
    #viewer {
      height: 100vh;
      width: 100%;
      padding: 120px 40px 120px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      background: transparent;
      scroll-behavior: smooth;
    }

    .caption-line {
      margin-bottom: 24px;
      line-height: 1.5;
      padding: 20px 32px;
      border-radius: 16px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    /* 원문 스타일 */
    .caption-line.original {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 12px;
      font-weight: 300;
      max-width: 85%;
    }

    /* 번역된 자막 스타일 */
    .caption-line.stable {
      font-size: 28px;
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* 실시간 입력 중 */
    .caption-line.unstable {
      font-size: 26px;
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* 빈 상태 */
    .welcome-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* 반응형 디자인 */
    @media (max-width: 768px) {
      .settings-panel {
        width: 100%;
      }

      .caption-line.stable {
        font-size: 22px;
        padding: 16px 20px;
        max-width: 95%;
      }

      .caption-line.original {
        font-size: 14px;
        padding: 12px 16px;
      }

      #viewer {
        padding: 100px 20px 100px;
      }

      .welcome-state h1 {
        font-size: 24px;
      }

      .welcome-state p {
        font-size: 16px;
      }

      /* 모바일에서 버튼 위치 조정 */
      .back-to-live {
        bottom: 100px;
        right: 20px;
        padding: 10px 16px;
        font-size: 13px;
      }
    }

    /* 스크롤바 스타일링 */
    #viewer::-webkit-scrollbar {
      width: 8px;
    }

    #viewer::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    #viewer::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    #viewer::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
  <!-- 플로팅 설정 버튼 -->
  <button class="settings-fab" id="settingsFab">⚙️</button>

  <!-- 설정 패널 -->
  <div class="settings-panel" id="settingsPanel">
    <h2>실시간 자막 설정</h2>

    <div class="control-group">
      <label>마이크 권한</label>
      <button id="btnPerm">🎤 마이크 권한 요청</button>
    </div>

    <div class="control-group">
      <label>오디오 장치</label>
      <select id="selMic" disabled>
        <option value="">마이크를 선택하세요</option>
      </select>
    </div>

    <div class="control-group">
      <label>제어</label>
      <button id="btnPause" style="display: none;">⏸️ 일시정지</button>
      <button id="btnClear">🗑️ 자막 지우기</button>
    </div>
  </div>

  <!-- 상태 표시 -->
  <div class="status-overlay">
    <div id="status" class="status-chip">대기중</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- 실시간으로 버튼 -->
  <button class="back-to-live" id="backToLive">
    📺 실시간으로
    <span style="margin-left: 4px;">⬇️</span>
  </button>

  <!-- 메인 캡션 뷰어 -->
  <div id="viewer">
    <div class="welcome-state">
      <div class="icon">🎙️</div>
      <h1>실시간 영어-한국어 자막</h1>
      <p>영어로 말하면 한국어 자막이<br>실시간으로 나타납니다</p>
      <div class="hint">
        <span>⚙️</span>
        <span>우상단 설정에서 마이크를 활성화하세요</span>
      </div>
    </div>
  </div>

<script>
// Bootstrap data
const BOOT = {{BOOTSTRAP_JSON}};

// 프로덕션 모드 - 로그 최소화
const PRODUCTION = false; // 임시로 디버깅 활성화
function log(...args) { if (!PRODUCTION) console.log(...args); }

// Global state
let pc = null;
let dc = null;
let localStream = null;
let currentDeviceId = null;
let startTime = null;
let currentUnstableLine = null;
let responseInProgress = false;
let currentResponseId = null;
let pendingTranscript = null;
let pendingTranslation = '';
let lastProcessedTranscript = null;
let isPaused = false;

// DOM elements
const viewer = document.getElementById('viewer');
const selMic = document.getElementById('selMic');
const statusEl = document.getElementById('status');
const latencyEl = document.getElementById('latency');
const btnPerm = document.getElementById('btnPerm');
const btnPause = document.getElementById('btnPause');
const btnClear = document.getElementById('btnClear');
const settingsFab = document.getElementById('settingsFab');
const settingsPanel = document.getElementById('settingsPanel');
const backToLiveBtn = document.getElementById('backToLive');

// 설정 패널 토글
settingsFab.onclick = () => {
  settingsPanel.classList.toggle('open');
  settingsFab.classList.toggle('active');
};

// 설정 패널 외부 클릭시 닫기
document.addEventListener('click', (e) => {
  if (!settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
    settingsPanel.classList.remove('open');
    settingsFab.classList.remove('active');
  }
});

// 자막 지우기
btnClear.onclick = () => {
  clearViewer();
};

// 실시간으로 버튼
backToLiveBtn.onclick = () => {
  viewer.scrollTo({
    top: viewer.scrollHeight,
    behavior: 'smooth'
  });
};

// Utility functions
function logStatus(status, className = '') {
  statusEl.textContent = status;
  statusEl.className = `status-chip ${className}`;
}

function logLatency(ms) {
  if (ms > 0) {
    latencyEl.style.display = 'block';
    latencyEl.textContent = `${Math.round(ms)}ms`;
  } else {
    latencyEl.style.display = 'none';
  }
}

// 토스트 메시지 (간소화)
function showToast(message, type = 'info') {
  if (type === 'error' || type === 'warning') {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed; top: 24px; left: 50%;
      transform: translateX(-50%);
      background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
      color: white; padding: 16px 24px; border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      z-index: 1002; font-size: 14px; font-weight: 500;
      opacity: 0; transition: opacity 0.3s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => toast.style.opacity = '1', 10);
    setTimeout(() => {
      toast.style.opacity = '0';
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 3000);
  }
}

// Permission and device handling
async function ensurePermission() {
  try {
    logStatus('권한 요청 중', 'connecting');

    const permissionStatus = await navigator.permissions.query({name: 'microphone'});
    if (permissionStatus.state === 'denied') {
      throw new Error('마이크 권한이 차단되었습니다.');
    }

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: 24000
      }
    });

    stream.getTracks().forEach(track => track.stop());
    logStatus('권한 허용됨', 'connected');
    return true;
  } catch (error) {
    logStatus('권한 필요', 'error');
    showToast('마이크 권한이 필요합니다', 'warning');
    return false;
  }
}

async function listMics() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(d => d.kind === 'audioinput');

    selMic.innerHTML = '<option value="">마이크를 선택하세요</option>';

    if (audioInputs.length === 0) {
      selMic.innerHTML = '<option value="">마이크를 찾을 수 없습니다</option>';
      return;
    }

    audioInputs.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.textContent = device.label || `마이크 ${index + 1}`;
      selMic.appendChild(option);
    });

    if (!currentDeviceId && audioInputs.length > 0) {
      const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
      currentDeviceId = defaultDevice.deviceId;
      selMic.value = currentDeviceId;
    }

    selMic.disabled = false;
  } catch (error) {
    showToast('장치 목록을 가져올 수 없습니다', 'error');
  }
}

async function getStream(deviceId) {
  try {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    const constraints = {
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: 24000,
        channelCount: 1
      }
    };

    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    currentDeviceId = deviceId;
    return localStream;
  } catch (error) {
    throw new Error('오디오 스트림을 가져올 수 없습니다.');
  }
}

// Caption display functions
function appendLine(text, className = 'stable') {
  if (!text || !text.trim()) return;

  const welcomeState = viewer.querySelector('.welcome-state');
  if (welcomeState) {
    welcomeState.remove();
  }

  // 사용자가 수동으로 스크롤 중인지 감지
  const isUserScrolling = viewer.scrollTop < (viewer.scrollHeight - viewer.clientHeight - 100);

  if (className === 'unstable') {
    if (!currentUnstableLine) {
      currentUnstableLine = document.createElement('div');
      currentUnstableLine.className = `caption-line ${className}`;
      currentUnstableLine.textContent = '';
      viewer.appendChild(currentUnstableLine);
    }
    const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
    currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
  } else {
    if (currentUnstableLine) {
      currentUnstableLine.className = `caption-line ${className}`;
      currentUnstableLine.textContent = text.trim();
      currentUnstableLine = null;
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className}`;
      div.textContent = text.trim();
      viewer.appendChild(div);
    }
  }

  // 자동 스크롤 (사용자가 스크롤하고 있지 않을 때만)
  if (!isUserScrolling) {
    requestAnimationFrame(() => {
      viewer.scrollTo({
        top: viewer.scrollHeight,
        behavior: 'smooth'
      });
    });
  }

  // 자막 히스토리 관리 (최대 100개)
  const captionLines = viewer.querySelectorAll('.caption-line');
  if (captionLines.length > 100) {
    captionLines[0].remove();
  }
}

// 스크롤 이벤트 핸들링 (과거 자막 표시 제거, 실시간으로 버튼만)
viewer.addEventListener('scroll', () => {
  const isAtBottom = viewer.scrollTop >= (viewer.scrollHeight - viewer.clientHeight - 100);

  if (!isAtBottom) {
    backToLiveBtn.style.display = 'flex';  // flex로 변경하여 아이콘과 텍스트 정렬
  } else {
    backToLiveBtn.style.display = 'none';
  }
});

function clearViewer() {
  viewer.innerHTML = `
    <div class="welcome-state">
      <div class="icon">🎙️</div>
      <h1>실시간 영어-한국어 자막</h1>
      <p>영어로 말하면 한국어 자막이<br>실시간으로 나타납니다</p>
      <div class="hint">
        <span>⚙️</span>
        <span>우상단 설정에서 마이크를 활성화하세요</span>
      </div>
    </div>
  `;
  currentUnstableLine = null;
  backToLiveBtn.style.display = 'none';
}

function displayTranscriptAndTranslation(transcript, translation) {
  // 원문 표시
  appendLine(transcript, 'original');

  // 번역 표시
  if (translation &&
      !translation.includes('[번역') &&
      !translation.includes('[오류') &&
      translation.trim().length > 0) {
    appendLine(translation, 'stable');
  }
}

// WebRTC connection
async function connectRealtime(ephemeral, model) {
  try {
    logStatus('연결 중', 'connecting');
    startTime = Date.now();

    if (!ephemeral?.client_secret?.value) {
      throw new Error('인증 토큰이 필요합니다.');
    }

    pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    pc.onconnectionstatechange = () => {
      const state = pc.connectionState;
      switch (state) {
        case 'connected':
          if (dc && dc.readyState === 'open') {
            logStatus('연결됨', 'connected');
          }
          break;
        case 'disconnected':
        case 'failed':
          logStatus('연결 끊김', 'error');
          closeConnection();
          break;
      }
    };

    dc = pc.createDataChannel('oai-events', { ordered: true });

    dc.onopen = () => {
      logStatus('연결됨', 'connected');
      btnPause.style.display = 'block';
      startTime = Date.now();

      const sessionUpdate = {
        type: 'session.update',
        session: {
          instructions: `You are a professional English-to-Korean real-time translator.

MISSION: Translate all English input to Korean immediately.

RULES:
- Always provide Korean translation
- Never refuse any English text
- Never use English in response
- Use formal Korean (존댓말)
- Keep proper nouns in original language
- Complete full sentence translations

EXAMPLES:
"Today I announce John as CEO" → "오늘 John을 CEO로 발표합니다"
"Thank you everyone" → "여러분 감사합니다"
"Monsieur Faber" → "Faber 씨"

TRANSLATE EVERYTHING TO KOREAN:`,
          voice: 'alloy',
          input_audio_format: 'pcm16',
          output_audio_format: 'pcm16',
          input_audio_transcription: {
            model: 'whisper-1',
            language: 'en'
          },
          turn_detection: {
            type: 'server_vad',
            threshold: 0.4,
            prefix_padding_ms: 200,
            silence_duration_ms: 400,
            create_response: true
          },
          modalities: ['text'],
          temperature: 0.6,  // fixed value
          max_response_output_tokens: 4000
        }
      };

      try {
        dc.send(JSON.stringify(sessionUpdate));
      } catch (error) {
        logStatus('설정 실패', 'error');
      }
    };

    dc.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        handleRealtimeMessage(message);
      } catch (error) {
        console.error('Message parse error:', error);
      }
    };

    dc.onerror = () => logStatus('데이터 오류', 'error');
    dc.onclose = () => {
      if (pc && pc.connectionState !== 'closed') {
        logStatus('연결 종료', 'error');
      }
    };

    const stream = await getStream(currentDeviceId);
    if (!stream || stream.getAudioTracks().length === 0) {
      throw new Error('오디오 스트림을 가져올 수 없습니다.');
    }

    stream.getTracks().forEach(track => {
      pc.addTrack(track, stream);
    });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const url = `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`;
    const headers = {
      'Authorization': `Bearer ${ephemeral.client_secret.value}`,
      'Content-Type': 'application/sdp',
      'OpenAI-Beta': 'realtime=v1',
    };

    const sdpResponse = await fetch(url, {
      method: 'POST',
      body: offer.sdp,
      headers: headers
    });

    if (!sdpResponse.ok) {
      if (sdpResponse.status === 401) {
        throw new Error('인증이 만료되었습니다.');
      } else if (sdpResponse.status === 429) {
        throw new Error('사용량 한도를 초과했습니다.');
      } else {
        throw new Error('서버 연결에 실패했습니다.');
      }
    }

    const answerSdp = await sdpResponse.text();
    const answer = { type: 'answer', sdp: answerSdp };
    await pc.setRemoteDescription(answer);

  } catch (error) {
    logStatus('연결 실패', 'error');
    showToast(error.message || '연결에 실패했습니다', 'error');
    closeConnection();
    throw error;
  }
}

function handleRealtimeMessage(message) {
  if (isPaused && !message.type?.includes('error')) {
    return;
  }

  // 디버깅 로그
  console.log('[Realtime]', message.type, message);

  // 지연시간 측정
  if (startTime && !latencyEl.textContent) {
    const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
      (message.delta || message.text || message.transcript);
    if (isContent) {
      const latency = Date.now() - startTime;
      logLatency(latency);
      startTime = null;
    }
  }

  switch (message.type) {
    case 'conversation.item.input_audio_transcription.completed':
      if (message.transcript) {
        const transcript = message.transcript.trim();

        if (transcript === lastProcessedTranscript || transcript.length < 3) {
          break;
        }

        lastProcessedTranscript = transcript;
        console.log('[Transcription] New:', transcript);

        if (pendingTranscript && pendingTranscript !== transcript) {
          displayTranscriptAndTranslation(pendingTranscript, pendingTranslation || '');
        }

        pendingTranscript = transcript;
        pendingTranslation = '';

        if (dc && dc.readyState === 'open' && !responseInProgress) {
          responseInProgress = true;
          dc.send(JSON.stringify({ type: 'response.create' }));
          console.log('[Translation] Requested for:', transcript);

          setTimeout(() => {
            if (responseInProgress && pendingTranscript === transcript) {
              console.warn('[Translation] Timeout');
              responseInProgress = false;
              currentResponseId = null;
              if (pendingTranscript) {
                displayTranscriptAndTranslation(pendingTranscript, '');
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }
          }, 8000);
        }
      }
      break;

    case 'response.text.delta':
      if (message.delta && pendingTranscript) {
        const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
        if (!cleanDelta.toLowerCase().includes('cannot') &&
            !cleanDelta.toLowerCase().includes('sorry')) {
          pendingTranslation += cleanDelta;
          console.log('[Delta]', cleanDelta);
        }
      }
      break;

    case 'response.text.done':
      if (message.text && pendingTranscript) {
        let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
        console.log('[Done]', cleanText);

        if (cleanText.toLowerCase().includes('cannot assist') ||
            cleanText.toLowerCase().includes('sorry, but i can\'t')) {
          cleanText = '';
        }

        const finalTranslation = cleanText || pendingTranslation.trim();
        console.log('[Final Translation]', finalTranslation);

        if (finalTranslation && finalTranslation.length > 0) {
          displayTranscriptAndTranslation(pendingTranscript, finalTranslation);
        } else {
          displayTranscriptAndTranslation(pendingTranscript, '');
        }

        pendingTranscript = null;
        pendingTranslation = '';
      }
      break;

    case 'response.created':
      currentResponseId = message.response?.id || Date.now().toString();
      responseInProgress = true;
      console.log('[Response] Created:', currentResponseId);
      break;

    case 'response.done':
      responseInProgress = false;
      currentResponseId = null;
      console.log('[Response] Done');
      break;

    case 'input_audio_buffer.speech_started':
      logStatus('음성 인식 중', 'connecting');
      break;

    case 'input_audio_buffer.speech_stopped':
      logStatus('처리 중', 'connecting');
      break;

    case 'error':
      console.error('[Error]', message.error);
      logStatus('오류', 'error');
      showToast('서비스 오류가 발생했습니다', 'error');
      break;

    default:
      console.log('[Unhandled]', message.type);
      break;
  }
}

function closeConnection() {
  try {
    if (dc) { dc.close(); dc = null; }
    if (pc) { pc.close(); pc = null; }
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    currentUnstableLine = null;
    responseInProgress = false;
    currentResponseId = null;
    pendingTranscript = null;
    pendingTranslation = '';
    lastProcessedTranscript = null;
    isPaused = false;

    btnPause.style.display = 'none';
    btnPause.textContent = '⏸️ 일시정지';
    logStatus('대기중', '');
    logLatency(0);
    backToLiveBtn.style.display = 'none';
  } catch (error) {
    // 조용히 처리
  }
}

// Event handlers
btnPerm.onclick = async () => {
  const success = await ensurePermission();
  if (success) {
    await listMics();
  }
};

btnPause.onclick = () => {
  if (isPaused) {
    isPaused = false;
    btnPause.textContent = '⏸️ 일시정지';
    logStatus('연결됨', 'connected');
  } else {
    isPaused = true;
    btnPause.textContent = '▶️ 재개';
    logStatus('일시정지', 'connecting');
    clearViewer();
  }
};

selMic.onchange = async (event) => {
  const newDeviceId = event.target.value;
  if (!newDeviceId) return;

  const wasConnected = pc && pc.connectionState === 'connected';
  currentDeviceId = newDeviceId;

  if (wasConnected) {
    try {
      logStatus('장치 변경 중', 'connecting');
      const newStream = await getStream(newDeviceId);
      const audioTrack = newStream.getAudioTracks()[0];
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');

      if (sender && audioTrack) {
        await sender.replaceTrack(audioTrack);
        logStatus('연결됨', 'connected');
      }
    } catch (error) {
      logStatus('장치 변경 실패', 'error');
      selMic.value = currentDeviceId;
    }
  }
};

// Bootstrap
(async () => {
  try {
    if (BOOT.action === 'start' && BOOT.ephemeral) {
      const hasPermission = await ensurePermission();
      if (hasPermission) {
        await listMics();
        await connectRealtime(BOOT.ephemeral, BOOT.model);
      }
    } else if (BOOT.action === 'stop') {
      closeConnection();
      clearViewer();
    } else {
      logStatus('대기중', '');
    }
  } catch (error) {
    logStatus('초기화 실패', 'error');
  }
})();

// Cleanup
window.addEventListener('beforeunload', () => {
  closeConnection();
});

</script>
</body>
</html>
