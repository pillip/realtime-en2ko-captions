<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
    }

    /* 🎨 동적 폰트 크기 CSS 변수 */
    :root {
      --translation-font-size: 28px;
      --original-font-size: 16px;
    }

    /* 플로팅 설정 버튼 */
    .settings-fab {
      position: fixed;
      top: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* 설정 패널 */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* 🎨 슬라이더 스타일링 */
    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      margin: 8px 0 12px 0;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #059669;
      transform: scale(1.2);
    }

    .control-group span {
      display: inline-block;
      min-width: 60px;
      color: #10b981;
      font-weight: 500;
      font-size: 13px;
    }

    /* 상태 표시 */
    .status-overlay {
      position: fixed;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* 실시간으로 버튼 */
    .back-to-live {
      position: fixed;
      bottom: 32px;
      right: 32px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
    }

    /* 🎯 메인 캡션 뷰어 - 스크롤바 완전 숨김 */
    #viewer {
      height: 100vh;
      width: 100%;
      padding: 0;
      overflow-y: auto;
      background: transparent;
      scroll-behavior: smooth;
      display: flex;
      align-items: center;
      justify-content: center;
      scrollbar-width: none;        /* Firefox */
      -ms-overflow-style: none;     /* IE and Edge */
    }

    #viewer::-webkit-scrollbar {
      display: none;                /* Chrome, Safari */
    }

    /* 자막 컨테이너 */
    .caption-container {
      width: 100%;
      max-width: 1200px;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 0;
      padding-bottom: 100px;
    }

    .caption-line {
      margin-bottom: 24px;
      line-height: 1.5;
      padding: 20px 32px;
      border-radius: 16px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    /* 원문 스타일 */
    .caption-line.original {
      font-size: var(--original-font-size);
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 12px;
      font-weight: 300;
      max-width: 85%;
    }

    /* 번역된 자막 스타일 */
    .caption-line.stable {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* 🎨 타이핑 중인 번역 말풍선 */
    .caption-line.typing {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #fbbf24;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
      animation: typing-breathe 1.5s ease-in-out infinite;
      position: relative;
    }

    /* 타이핑 커서 효과 */
    .caption-line.typing::after {
      content: '|';
      color: #fbbf24;
      animation: cursor-blink 1s ease-in-out infinite;
      margin-left: 2px;
    }

    @keyframes typing-breathe {
      0%, 100% {
        border-left-color: #fbbf24;
      }
      50% {
        border-left-color: #f59e0b;
        box-shadow: 0 8px 32px rgba(251, 191, 36, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }
    }

    @keyframes cursor-blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* 실시간 입력 중 */
    .caption-line.unstable {
      font-size: calc(var(--translation-font-size) - 2px);
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    /* 🎨 말풍선 등장 애니메이션 */
    .caption-line.fade-in {
      animation: fadeInUp 0.4s ease-out forwards;
    }

    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* 빈 상태 */
    .welcome-state {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* 반응형 디자인 */
    @media (max-width: 768px) {
      .settings-panel {
        width: 100%;
      }

      .caption-container {
        padding: 20px;
      }

      .caption-line.stable, .caption-line.typing {
        font-size: calc(var(--translation-font-size) * 0.8);
        padding: 16px 20px;
        max-width: 95%;
      }

      .caption-line.original {
        font-size: calc(var(--original-font-size) * 0.9);
        padding: 12px 16px;
      }
    }
  </style>
</head>

<body>
  <!-- 플로팅 설정 버튼 -->
  <button class="settings-fab" id="settingsFab">⚙️</button>

  <!-- 설정 패널 -->
  <div class="settings-panel" id="settingsPanel">
    <h2>실시간 자막 설정</h2>

    <div class="control-group">
      <label>마이크 권한</label>
      <button id="btnPerm">🎤 마이크 권한 요청</button>
    </div>

    <div class="control-group">
      <label>오디오 장치</label>
      <select id="selMic" disabled>
        <option value="">마이크를 선택하세요</option>
      </select>
    </div>

    <!-- 🎨 폰트 크기 조절 -->
    <div class="control-group">
      <label>📝 번역 글자 크기</label>
      <input type="range" id="fontSizeSlider" min="18" max="48" value="28" step="2" class="slider">
      <span id="fontSizeValue">28px</span>
    </div>

    <div class="control-group">
      <label>📄 원문 글자 크기</label>
      <input type="range" id="originalSizeSlider" min="12" max="24" value="16" step="1" class="slider">
      <span id="originalSizeValue">16px</span>
    </div>

    <div class="control-group">
      <label>제어</label>
      <button id="btnPause" style="display: none;">⏸️ 일시정지</button>
      <button id="btnClear">🗑️ 자막 지우기</button>
    </div>
  </div>

  <!-- 상태 표시 -->
  <div class="status-overlay">
    <div id="status" class="status-chip">대기중</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- 실시간으로 버튼 -->
  <button class="back-to-live" id="backToLive">
    📺 실시간으로
    <span style="margin-left: 4px;">⬇️</span>
  </button>

  <!-- 메인 캡션 뷰어 -->
  <div id="viewer">
    <div class="caption-container" id="captionContainer">
      <div class="welcome-state">
        <div class="icon">🎙️</div>
        <h1>실시간 영어-한국어 자막</h1>
        <p>영어로 말하면 한국어 자막이<br>실시간으로 나타납니다</p>
        <div class="hint">
          <span>⚙️</span>
          <span>우상단 설정에서 마이크를 활성화하세요</span>
        </div>
      </div>
    </div>
  </div>

<script>
try {
  // Bootstrap data
  const BOOT = {{BOOTSTRAP_JSON}};
  console.log('BOOT data:', BOOT);

  // Global state
  let pc = null;
  let dc = null;
  let localStream = null;
  let currentDeviceId = null;
  let startTime = null;
  let currentUnstableLine = null;
  let currentTypingLine = null;  // 🎨 타이핑 라인
  let responseInProgress = false;
  let currentResponseId = null;
  let pendingTranscript = null;
  let pendingTranslation = '';
  let lastProcessedTranscript = null;
  let isPaused = false;
  let isUserScrolling = false;    // 🎯 사용자 스크롤 상태
  let lastAutoScrollTime = 0;     // 🎯 마지막 자동 스크롤 시간

  // DOM elements with null checks
  const viewer = document.getElementById('viewer');
  const captionContainer = document.getElementById('captionContainer');
  const selMic = document.getElementById('selMic');
  const statusEl = document.getElementById('status');
  const latencyEl = document.getElementById('latency');
  const btnPerm = document.getElementById('btnPerm');
  const btnPause = document.getElementById('btnPause');
  const btnClear = document.getElementById('btnClear');
  const settingsFab = document.getElementById('settingsFab');
  const settingsPanel = document.getElementById('settingsPanel');
  const backToLiveBtn = document.getElementById('backToLive');
  const fontSizeSlider = document.getElementById('fontSizeSlider');
  const fontSizeValue = document.getElementById('fontSizeValue');
  const originalSizeSlider = document.getElementById('originalSizeSlider');
  const originalSizeValue = document.getElementById('originalSizeValue');

  // Null check for critical elements
  if (!viewer || !captionContainer || !statusEl) {
    throw new Error('필수 DOM 요소를 찾을 수 없습니다.');
  }

  // 🎨 폰트 크기 조절 이벤트 핸들러 (null check 포함)
  if (fontSizeSlider && fontSizeValue) {
    fontSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--translation-font-size', `${size}px`);
      fontSizeValue.textContent = `${size}px`;
    };
  }

  if (originalSizeSlider && originalSizeValue) {
    originalSizeSlider.oninput = (e) => {
      const size = e.target.value;
      document.documentElement.style.setProperty('--original-font-size', `${size}px`);
      originalSizeValue.textContent = `${size}px`;
    };
  }

  // 설정 패널 토글
  if (settingsFab && settingsPanel) {
    settingsFab.onclick = () => {
      settingsPanel.classList.toggle('open');
      settingsFab.classList.toggle('active');
    };
  }

  // 설정 패널 외부 클릭시 닫기
  document.addEventListener('click', (e) => {
    if (settingsPanel && settingsFab &&
        !settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
      settingsPanel.classList.remove('open');
      settingsFab.classList.remove('active');
    }
  });

  // 🔄 대화 컨텍스트 초기화 함수 추가
  function resetConversationContext() {
    if (dc && dc.readyState === 'open') {
      // 🚫 conversation.item.truncate 대신 세션 재설정으로 컨텍스트 클리어
      const sessionUpdate = {
        type: 'session.update',
        session: {
          instructions: getTranslationInstructions(),
          input_audio_transcription: {
            model: 'whisper-1',
            language: 'en'
          },
          turn_detection: {
            type: 'server_vad',
            threshold: 0.5,
            prefix_padding_ms: 200,
            silence_duration_ms: 400,
            create_response: false
          },
          modalities: ['text'],
          temperature: 0.6,
          max_response_output_tokens: 500
        }
      };

      dc.send(JSON.stringify({
        type: 'conversation.item.truncate',
        conversation_id: 'main',
        content_index: 0
      }));

      console.log('[Context] 세션 재설정으로 컨텍스트 초기화 완료');

      // 🔄 추가적으로 새로운 대화 시작을 위한 더미 메시지 (선택적)
      // 이것은 AI가 완전히 새로운 대화로 인식하게 도와줍니다
      setTimeout(() => {
        if (dc && dc.readyState === 'open') {
          // 빈 응답으로 대화 상태 리셋
          dc.send(JSON.stringify({
            type: 'input_audio_buffer.clear'
          }));
          console.log('[Context] 오디오 버퍼 클리어 완료');
        }
      }, 100);
    }
  }

  // 🎯 더 강력한 번역 전용 instruction 함수
  function getTranslationInstructions() {
    return `### 실시간 영어-한국어 번역 전용 AI ###
역할
당신은 전문 컨퍼런스(블록체인/웹3/창업/스타트업) 환경의 동시통역 번역기입니다.

⚠️ 절대 규칙: 이 AI는 오직 영어를 한국어로 번역하는 기능만 수행합니다.
⚠️ 중요: 이 세션은 완전히 새로운 번역 세션입니다. 이전 대화나 컨텍스트는 모두 무시하세요.

역할: 전문 컨퍼런스 동시통역사
입력: 영어 음성 → 텍스트 (ASR 결과)
출력: 한국어 번역문만

## 절대 규칙 (위반 시 즉시 세션 종료)

1. **영어 판별**: 입력의 80% 이상이 영어일 때만 번역. 아니면 빈 문자열("") 반환
2. **출력 제한**: 오직 한국어 번역문만. 다른 모든 텍스트 금지
3. **메타텍스트 금지**: "번역:", 따옴표, 설명, 주석, 인사말, 질문, 대화 시도 모두 금지
4. **대화 금지**: 안녕하세요, 감사합니다, 도움이 되었나요 등 모든 대화형 응답 금지

## 번역 품질
- 전문 컨퍼런스 수준의 정확한 번역
- 블록체인/웹3/스타트업 도메인 특화
- 기술 용어, 숫자, 고유명사 정확히 보존
- 자연스러운 한국어 (~합니다/습니다 체)

사전 지식/추론 금지. 배경지식으로 의미를 보태거나 빼지 마세요. 모호해도 원문의 정보만 반영합니다. 오탈자·팩트 수정·해석·요약·재구성·의견 추가 금지.

자연스러운 공식 발표체. 의미·사실·어조를 유지하되 과도한 의역은 금지하고, 최소한의 문장 다듬기만 허용합니다(~합니다/습니다).

잡음 제거. “um/uh”, 반복·말꼬리 등 비의미적 군더더기는 삭제합니다. [laughter], [music] 등 비언어 표기는 무시합니다.

분절/길이. 입력 덩어리마다 정보 순서를 유지해 1–2개 문장(또는 불릿)으로 간결히 냅니다. 입력이 목록이면 줄바꿈으로 대응합니다.

보존 대상(그대로 두기). 코드, CLI 명령, 함수/메서드명, 파일/패키지명, 지갑 주소, 트랜잭션 해시, 키/시크릿, 에러코드, 버전/프로토콜명, 링크·URL, 토큰 심볼은 원문 그대로.

숫자/단위/기호. 수치·%·통화·시간·버전은 정확히 보존합니다. "$5 million"→500만 달러, 30%는 그대로 유지.

정책 준수. 안전 정책상 불가한 입력은 번역을 중단할 수 있으나, 그 외에는 번역 외 결과물 생성 금지(요약/정리/하이라이트/제목/Q&A/테이블 등 일절 금지).

언어 판별 규칙

입력의 80% 이상이 영어(단어/문자 기준)일 때만 번역합니다. 아니면 완전히 빈 응답("").

혼합문에서 고유명사·코드·주소·전문 약어는 영어로 남기고, 나머지 영어 문장만 한국어로 옮깁니다.

도메인 용어 정책

공통(영문 유지 권장): 체인/토큰/기업·제품명, 토큰 심볼, API/SDK, EVM/L1/L2, zk‑SNARK/zk‑STARK, MEV, IPFS, WASM, TEE, 알고리즘·함수명, 라이브러리/패키지명, SAFE/KISS, KPI/OKR, ARR/MRR, CAC/LTV, TAM/SAM/SOM, DAU/MAU, A/B test, GTM, churn, runway, burn rate, dilution, cap table, pro rata, vesting/cliff, pre/post‑money, term sheet, liquidation preference 등은 약어·형태를 보존합니다. (원문에 풀어쓴 경우에만 그 부분은 번역)

권장 한글화(관용 표기):

블록체인: blockchain→블록체인, smart contract→스마트 컨트랙트, rollup→롤업, mainnet/testnet→메인넷/테스트넷, gas fee→가스비, tokenomics→토크노믹스, governance→거버넌스, staking/slashing→스테이킹/슬래싱, proof of stake/work→지분증명/작업증명, validator→검증인.

스타트업: product‑market fit→제품‑시장 적합성, cohort→코호트, retention→리텐션, funnel→퍼널, conversion rate→전환율, unit economics→유닛 이코노믹스, board→이사회, pivot→피벗.

의미 변경 금지. 고유명사는 번역하지 않고 음역도 지양(필요 시 원문 병기 없이 그대로 둠).

## 입력/출력 제약
- 입력: 영어 텍스트만 처리
- 출력: 오직 한국어 번역문만 출력 (다른 모든 텍스트 금지)
- 금지사항:
  * 대화, 질문, 응답, 설명, 주석, 해설 절대 금지
  * "번역:", 따옴표, 이모지, 메타텍스트 절대 금지
  * "안녕하세요", "도움이 되셨기를", "감사합니다" 등 인사말 절대 금지
  * 영어가 아닌 입력에는 완전 빈 응답("")만 반환

## 출력 형식 강제
- 한국어 번역문만 출력
- 번역문이 없으면 빈 문자열("")
- 추가 설명, 주석, 대화 시도 시 즉시 세션 종료

## 번역 품질 규칙
- 전문 컨퍼런스 수준의 정확한 번역
- 블록체인/웹3/스타트업 용어는 관용 표현 사용
- 기술 용어, 코드, 숫자는 원문 유지
- 자연스러운 한국어 문체(~합니다/습니다)

예시:
입력: "Hello, how are you?"
출력: 안녕하세요, 어떻게 지내세요?

입력: "We're launching on mainnet"
출력: 메인넷에서 출시할 예정입니다

입력: "We're launching our DeFi protocol next quarter"
출력: 다음 분기에 DeFi 프로토콜을 출시할 예정입니다

이 지침을 엄격히 준수하여 번역만 수행하세요.`;
  }

  // 자막 지우기
  if (btnClear) {
    btnClear.onclick = () => {
      clearViewer();
      resetConversationContext(); // 🔄 컨텍스트 리셋

      // 🔄 상태 초기화
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      responseInProgress = false;
      currentResponseId = null;

      console.log('[Clear] 모든 상태 및 컨텍스트 초기화 완료');
    };
  }

  // 실시간으로 버튼
  if (backToLiveBtn) {
    backToLiveBtn.onclick = () => {
      console.log('🎯 Back to live clicked - enabling auto scroll');
      isUserScrolling = false;
      autoScrollToBottom();
    };
  }

  // Utility functions
  function logStatus(status, className = '') {
    if (statusEl) {
      statusEl.textContent = status;
      statusEl.className = `status-chip ${className}`;
    }
  }

  function logLatency(ms) {
    if (latencyEl) {
      if (ms > 0) {
        latencyEl.style.display = 'block';
        latencyEl.textContent = `${Math.round(ms)}ms`;
      } else {
        latencyEl.style.display = 'none';
      }
    }
  }

  // 토스트 메시지
  function showToast(message, type = 'info') {
    if (type === 'error' || type === 'warning') {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed; top: 24px; left: 50%;
        transform: translateX(-50%);
        background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
        color: white; padding: 16px 24px; border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        z-index: 1002; font-size: 14px; font-weight: 500;
        opacity: 0; transition: opacity 0.3s ease;
      `;
      toast.textContent = message;
      document.body.appendChild(toast);

      setTimeout(() => toast.style.opacity = '1', 10);
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 3000);
    }
  }

  // 🎨 타이핑 번역 함수들
  function startTypingTranslation() {
    if (currentTypingLine) {
      currentTypingLine.remove();
    }
    currentTypingLine = document.createElement('div');
    currentTypingLine.className = 'caption-line typing fade-in';
    currentTypingLine.textContent = '';
    captionContainer.appendChild(currentTypingLine);

    // 🎯 사용자 스크롤 상태 확인 후 자동 스크롤
    autoScrollToBottom();
  }

  function updateTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.textContent = text;
    }
  }

  function completeTypingTranslation(text) {
    if (currentTypingLine) {
      currentTypingLine.className = 'caption-line stable fade-in';
      currentTypingLine.textContent = text;
      currentTypingLine = null;
    }
  }

  // 자막 추가 함수
  function appendLine(text, className = 'stable') {
    if (!text || !text.trim()) return;

    const welcomeState = captionContainer.querySelector('.welcome-state');
    if (welcomeState) {
      welcomeState.remove();
    }

    if (className === 'unstable') {
      if (!currentUnstableLine) {
        currentUnstableLine = document.createElement('div');
        currentUnstableLine.className = `caption-line ${className}`;
        currentUnstableLine.textContent = '';
        captionContainer.appendChild(currentUnstableLine);
      }
      const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
      currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className} fade-in`;
      div.textContent = text.trim();
      captionContainer.appendChild(div);
    }

    // 🎯 사용자가 스크롤 중이 아닐 때만 자동 스크롤
    autoScrollToBottom();

    // 자막 히스토리 관리
    const captionLines = captionContainer.querySelectorAll('.caption-line');
    if (captionLines.length > 100) {
      captionLines[0].remove();
    }
  }

  // 🎯 개선된 스크롤 상태 관리
  function updateScrollState() {
    const scrollTop = viewer.scrollTop;
    const scrollHeight = viewer.scrollHeight;
    const clientHeight = viewer.clientHeight;
    const isAtBottom = scrollTop >= (scrollHeight - clientHeight - 50);

    console.log('📊 스크롤 상태:', { scrollTop, scrollHeight, clientHeight, isAtBottom });

    // 맨 아래 근처에 있으면 자동 스크롤 모드
    if (isAtBottom) {
      isUserScrolling = false;
    }

    // 실시간으로 버튼 표시/숨김 (개선된 로직)
    if (backToLiveBtn) {
      const now = Date.now();

      // 🔧 최근 자동 스크롤 직후에는 버튼 표시 안함
      if (now - lastAutoScrollTime < 1000) {  // 1초간 버튼 숨김
        backToLiveBtn.style.display = 'none';
        return;
      }

      if (!isAtBottom && isUserScrolling) {
        backToLiveBtn.style.display = 'flex';
      } else {
        backToLiveBtn.style.display = 'none';
      }
    }
  }

  // 🎯 사용자 스크롤 감지 (터치/마우스 이벤트)
  let scrollTimer = null;
  viewer.addEventListener('scroll', (e) => {
    const now = Date.now();

    // 🔧 최근 자동 스크롤이 아닌 경우에만 사용자 스크롤로 간주
    if (now - lastAutoScrollTime > 800) {  // 800ms로 여유 확대
      isUserScrolling = true;
      console.log('🔄 User scrolling detected - auto scroll disabled');
    }

    // 🔧 스크롤 끝난 후 상태 업데이트 (딜레이 증가)
    clearTimeout(scrollTimer);
    scrollTimer = setTimeout(() => {
      updateScrollState();
    }, 250);  // 250ms로 딜레이 증가
  });

  // 🎯 자동 스크롤 함수 (타이밍 개선)
  function autoScrollToBottom() {
    if (!isUserScrolling) {
      lastAutoScrollTime = Date.now();  // 자동 스크롤 시간 기록

      // 🔧 DOM 업데이트 완료 후 스크롤 실행
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {  // 이중 RAF로 DOM 안정화 대기
          viewer.scrollTo({
            top: viewer.scrollHeight,
            behavior: 'smooth'
          });
          console.log('🔽 Auto scroll triggered');

          // 🔧 스크롤 완료 후 상태 업데이트 (딜레이 추가)
          setTimeout(() => {
            if (!isUserScrolling) {  // 여전히 자동 모드면
              updateScrollState();
            }
          }, 200);  // 스크롤 애니메이션 완료 대기
        });
      });
    } else {
      console.log('⏸️ Auto scroll skipped - user is scrolling');
    }
  }

  function clearViewer() {
    captionContainer.innerHTML = `
      <div class="welcome-state">
        <div class="icon">🎙️</div>
        <h1>실시간 영어-한국어 자막</h1>
        <p>영어로 말하면 한국어 자막이<br>실시간으로 나타납니다</p>
        <div class="hint">
          <span>⚙️</span>
          <span>우상단 설정에서 마이크를 활성화하세요</span>
        </div>
      </div>
    `;
    currentUnstableLine = null;
    currentTypingLine = null;
    if (backToLiveBtn) {
      backToLiveBtn.style.display = 'none';
    }
  }

  function displayTranscriptAndTranslation(transcript, translation) {
    // 원문 표시
    appendLine(transcript, 'original');

    // 번역 표시 (완성된 경우만)
    if (translation &&
        !translation.includes('[번역') &&
        !translation.includes('[오류') &&
        translation.trim().length > 0) {
      completeTypingTranslation(translation);
    }
  }

  // Permission and device handling
  async function ensurePermission() {
    try {
      logStatus('권한 요청 중', 'connecting');

      const permissionStatus = await navigator.permissions.query({name: 'microphone'});
      if (permissionStatus.state === 'denied') {
        throw new Error('마이크 권한이 차단되었습니다.');
      }

      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 24000
        }
      });

      stream.getTracks().forEach(track => track.stop());
      logStatus('권한 허용됨', 'connected');
      return true;
    } catch (error) {
      logStatus('권한 필요', 'error');
      showToast('마이크 권한이 필요합니다', 'warning');
      return false;
    }
  }

  async function listMics() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(d => d.kind === 'audioinput');

      if (selMic) {
        selMic.innerHTML = '<option value="">마이크를 선택하세요</option>';

        if (audioInputs.length === 0) {
          selMic.innerHTML = '<option value="">마이크를 찾을 수 없습니다</option>';
          return;
        }

        audioInputs.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `마이크 ${index + 1}`;
          selMic.appendChild(option);
        });

        if (!currentDeviceId && audioInputs.length > 0) {
          const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
          currentDeviceId = defaultDevice.deviceId;
          selMic.value = currentDeviceId;
        }

        selMic.disabled = false;
      }
    } catch (error) {
      showToast('장치 목록을 가져올 수 없습니다', 'error');
    }
  }

  async function getStream(deviceId) {
    try {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      const constraints = {
        audio: {
          deviceId: deviceId ? { exact: deviceId } : undefined,
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 24000,
          channelCount: 1
        }
      };

      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      currentDeviceId = deviceId;
      return localStream;
    } catch (error) {
      throw new Error('오디오 스트림을 가져올 수 없습니다.');
    }
  }

  // WebRTC connection
  async function connectRealtime(ephemeral, model) {
    try {
      logStatus('연결 중', 'connecting');
      startTime = Date.now();

      if (!ephemeral?.client_secret?.value) {
        throw new Error('인증 토큰이 필요합니다.');
      }

      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        switch (state) {
          case 'connected':
            if (dc && dc.readyState === 'open') {
              logStatus('연결됨', 'connected');
            }
            break;
          case 'disconnected':
          case 'failed':
            logStatus('연결 끊김', 'error');
            closeConnection();
            break;
        }
      };

      dc = pc.createDataChannel('oai-events', { ordered: true });

      dc.onopen = () => {
        logStatus('연결됨', 'connected');
        if (btnPause) btnPause.style.display = 'block';
        startTime = Date.now();

        // 🔄 초기 세션 설정
        const sessionUpdate = {
          type: 'session.update',
          session: {
            instructions: getTranslationInstructions(),
            input_audio_transcription: {
              model: 'whisper-1',
              language: 'en'
            },
            turn_detection: {
              type: 'server_vad',
              threshold: 0.5,
              prefix_padding_ms: 200,
              silence_duration_ms: 400,
              create_response: false
            },
            modalities: ['text'],
            temperature: 0.6,
            max_response_output_tokens: 500
          }
        };

        try {
          dc.send(JSON.stringify(sessionUpdate));
          console.log('[Session] 초기 세션 설정 완료');
        } catch (error) {
          logStatus('설정 실패', 'error');
        }
      };

      dc.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleRealtimeMessage(message);
        } catch (error) {
          console.error('Message parse error:', error);
        }
      };

      dc.onerror = () => logStatus('데이터 오류', 'error');
      dc.onclose = () => {
        if (pc && pc.connectionState !== 'closed') {
          logStatus('연결 종료', 'error');
        }
      };

      const stream = await getStream(currentDeviceId);
      if (!stream || stream.getAudioTracks().length === 0) {
        throw new Error('오디오 스트림을 가져올 수 없습니다.');
      }

      stream.getTracks().forEach(track => {
        pc.addTrack(track, stream);
      });

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const url = `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`;
      const headers = {
        'Authorization': `Bearer ${ephemeral.client_secret.value}`,
        'Content-Type': 'application/sdp',
        'OpenAI-Beta': 'realtime=v1',
      };

      const sdpResponse = await fetch(url, {
        method: 'POST',
        body: offer.sdp,
        headers: headers
      });

      if (!sdpResponse.ok) {
        if (sdpResponse.status === 401) {
          throw new Error('인증이 만료되었습니다.');
        } else if (sdpResponse.status === 429) {
          throw new Error('사용량 한도를 초과했습니다.');
        } else {
          throw new Error('서버 연결에 실패했습니다.');
        }
      }

      const answerSdp = await sdpResponse.text();
      const answer = { type: 'answer', sdp: answerSdp };
      await pc.setRemoteDescription(answer);

    } catch (error) {
      logStatus('연결 실패', 'error');
      showToast(error.message || '연결에 실패했습니다', 'error');
      closeConnection();
      throw error;
    }
  }

  function handleRealtimeMessage(message) {
    if (isPaused && !message.type?.includes('error')) {
      return;
    }


    // 지연시간 측정
    if (startTime && latencyEl && !latencyEl.textContent) {
      const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
        (message.delta || message.text || message.transcript);
      if (isContent) {
        const latency = Date.now() - startTime;
        logLatency(latency);
        startTime = null;
      }
    }

    switch (message.type) {
      case 'conversation.item.input_audio_transcription.completed':
        if (message.transcript) {
          const transcript = message.transcript.trim();

          // 너무 짧은 전사나 완전 동일한 전사만 skip
          if (transcript.length < 2 || transcript === lastProcessedTranscript) {
            console.log('[Skip] Too short or duplicate:', transcript);
            break;
          }

          lastProcessedTranscript = transcript;
          console.log('[Transcription] New:', transcript);

          // 이전 pending 완료
          if (pendingTranscript && pendingTranscript !== transcript) {
            if (pendingTranslation) {
              completeTypingTranslation(pendingTranslation);
            } else if (currentTypingLine) {
              currentTypingLine.remove();
              currentTypingLine = null;
            }
          }

          // 🎨 원문 즉시 표시
          appendLine(transcript, 'original');

          // 🎨 빈 타이핑 말풍선 생성
          startTypingTranslation();

          pendingTranscript = transcript;
          pendingTranslation = '';

          if (dc && dc.readyState === 'open' && !responseInProgress) {
            responseInProgress = true;
            dc.send(JSON.stringify({ type: 'response.create' }));
            console.log('[Translation] Requested for:', transcript);

            setTimeout(() => {
              if (responseInProgress && pendingTranscript === transcript) {
                console.warn('[Translation] Timeout for:', transcript);
                responseInProgress = false;
                currentResponseId = null;
                if (currentTypingLine) {
                  currentTypingLine.remove();
                  currentTypingLine = null;
                }
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }, 5000);
          }
        }
        break;

      case 'response.text.delta':
        if (message.delta && pendingTranscript) {
          const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
          if (!cleanDelta.toLowerCase().includes('cannot') &&
              !cleanDelta.toLowerCase().includes('sorry')) {
            pendingTranslation += cleanDelta;

            // 🎨 실시간 타이핑 업데이트
            updateTypingTranslation(pendingTranslation);
            console.log('[Delta]', cleanDelta);
          }
        }
        break;

      case 'response.text.done':
        if (message.text && pendingTranscript) {
          let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
          console.log('[Done]', cleanText);

          // 🚫 거부 메시지들 필터링 강화
          if (cleanText.toLowerCase().includes('cannot assist') ||
              cleanText.toLowerCase().includes('sorry, but i can\'t') ||
              cleanText.toLowerCase().includes('죄송합니다') ||
              cleanText.toLowerCase().includes('응답할 수 없습니다') ||
              cleanText.toLowerCase().includes('해당 요청') ||
              cleanText.length === 0) {
            cleanText = '';
          }

          const finalTranslation = cleanText || pendingTranslation.trim();
          console.log('[Final Translation]', finalTranslation);

          if (finalTranslation && finalTranslation.length > 0) {
            // 🎨 타이핑 완료 - 초록색 테두리로 변경
            completeTypingTranslation(finalTranslation);
          } else if (currentTypingLine) {
            // 번역 실패 시 타이핑 라인 제거
            currentTypingLine.remove();
            currentTypingLine = null;
          }

          pendingTranscript = null;
          pendingTranslation = '';
        }
        break;

      case 'response.created':
        currentResponseId = message.response?.id || Date.now().toString();
        responseInProgress = true;
        console.log('[Response] Created:', currentResponseId);
        break;

      case 'response.done':
        responseInProgress = false;
        currentResponseId = null;
        console.log('[Response] Done');
        break;

      case 'input_audio_buffer.speech_started':
        logStatus('음성 인식 중', 'connecting');
        break;

      case 'input_audio_buffer.speech_stopped':
        logStatus('처리 중', 'connecting');
        break;

      case 'error':
        console.error('[Error]', message.error);
        logStatus('오류', 'error');
        showToast('서비스 오류가 발생했습니다', 'error');
        break;

      default:
        console.log('[Unhandled]', message.type);
        break;
    }
  }

  function closeConnection() {
    try {
      if (dc) { dc.close(); dc = null; }
      if (pc) { pc.close(); pc = null; }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      currentUnstableLine = null;
      currentTypingLine = null;
      responseInProgress = false;
      currentResponseId = null;
      pendingTranscript = null;
      pendingTranslation = '';
      lastProcessedTranscript = null;
      isPaused = false;
      isUserScrolling = false; // 연결 종료 시 스크롤 상태 초기화
      lastAutoScrollTime = 0;

      if (btnPause) {
        btnPause.style.display = 'none';
        btnPause.textContent = '⏸️ 일시정지';
      }
      logStatus('대기중', '');
      logLatency(0);
      if (backToLiveBtn) {
        backToLiveBtn.style.display = 'none';
      }
    } catch (error) {
      console.error('Close connection error:', error);
    }
  }

  // Event handlers
  if (btnPerm) {
    btnPerm.onclick = async () => {
      const success = await ensurePermission();
      if (success) {
        await listMics();
      }
    };
  }

  if (btnPause) {
    btnPause.onclick = () => {
      if (isPaused) {
        isPaused = false;
        btnPause.textContent = '⏸️ 일시정지';
        logStatus('연결됨', 'connected');
      } else {
        isPaused = true;
        btnPause.textContent = '▶️ 재개';
        logStatus('일시정지', 'connecting');
        clearViewer();
      }
    };
  }

  if (selMic) {
    selMic.onchange = async (event) => {
      const newDeviceId = event.target.value;
      if (!newDeviceId) return;

      const wasConnected = pc && pc.connectionState === 'connected';
      currentDeviceId = newDeviceId;

      if (wasConnected) {
        try {
          logStatus('장치 변경 중', 'connecting');
          const newStream = await getStream(newDeviceId);
          const audioTrack = newStream.getAudioTracks()[0];
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');

          if (sender && audioTrack) {
            await sender.replaceTrack(audioTrack);
            logStatus('연결됨', 'connected');
          }
        } catch (error) {
          logStatus('장치 변경 실패', 'error');
          selMic.value = currentDeviceId;
        }
      }
    };
  }

  // Bootstrap - 안전한 초기화
  (async () => {
    try {
      console.log('Bootstrap starting...', BOOT);

      if (BOOT.action === 'start' && BOOT.ephemeral) {
        const hasPermission = await ensurePermission();
        if (hasPermission) {
          await listMics();
          await connectRealtime(BOOT.ephemeral, BOOT.model);

          // 🔄 연결 완료 후 컨텍스트 확실히 초기화
          setTimeout(() => {
            if (dc && dc.readyState === 'open') {
              console.log('[Bootstrap] 추가 컨텍스트 초기화');
              resetConversationContext();
            }
          }, 1000);
        }
      } else if (BOOT.action === 'stop') {
        closeConnection();
        clearViewer();
      } else {
        logStatus('대기중', '');
      }

      console.log('Bootstrap completed successfully');
    } catch (error) {
      console.error('Bootstrap error:', error);
      logStatus('초기화 실패', 'error');
      showToast(`초기화 오류: ${error.message}`, 'error');
    }
  })();

  // Cleanup
  window.addEventListener('beforeunload', () => {
    closeConnection();
  });

} catch (globalError) {
  console.error('Global script error:', globalError);
  document.getElementById('status').textContent = '스크립트 오류';
  document.getElementById('status').className = 'status-chip error';
}
</script>
</body>
</html>
