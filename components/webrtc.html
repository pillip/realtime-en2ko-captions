<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
      color: #ffffff;
      overflow: hidden;
      height: 100vh;
    }

    /* ğŸ¨ ë™ì  í°íŠ¸ í¬ê¸° CSS ë³€ìˆ˜ */
    :root {
      --translation-font-size: 28px;
      --original-font-size: 16px;
    }

    /* í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ */
    .settings-fab {
      position: fixed;
      top: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      z-index: 1001;
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .settings-fab:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.1);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
    }

    .settings-fab.active {
      background: rgba(59, 130, 246, 0.3);
      color: #3b82f6;
    }

    /* ì„¤ì • íŒ¨ë„ */
    .settings-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 380px;
      height: 100vh;
      background: rgba(15, 15, 35, 0.95);
      backdrop-filter: blur(20px);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      padding: 100px 28px 28px;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 1000;
      box-shadow: -10px 0 50px rgba(0, 0, 0, 0.5);
      overflow-y: auto;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-panel h2 {
      margin: 0 0 32px 0;
      color: #ffffff;
      font-size: 24px;
      font-weight: 300;
    }

    .control-group {
      margin-bottom: 32px;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      color: #a0a0a0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    .control-group button {
      width: 100%;
      padding: 16px 20px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      cursor: pointer;
      font-size: 15px;
      font-weight: 500;
      transition: all 0.3s ease;
      margin-bottom: 12px;
    }

    .control-group button:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .control-group button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .control-group select {
      width: 100%;
      padding: 16px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.08);
      color: white;
      font-size: 15px;
    }

    /* ğŸ¨ ìŠ¬ë¼ì´ë” ìŠ¤íƒ€ì¼ë§ */
    .slider {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      margin: 8px 0 12px 0;
      -webkit-appearance: none;
    }

    .slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #10b981;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .slider::-webkit-slider-thumb:hover {
      background: #059669;
      transform: scale(1.2);
    }

    .control-group span {
      display: inline-block;
      min-width: 60px;
      color: #10b981;
      font-weight: 500;
      font-size: 13px;
    }

    /* ìƒíƒœ í‘œì‹œ */
    .status-overlay {
      position: fixed;
      bottom: 32px;
      left: 32px;
      display: flex;
      gap: 16px;
      align-items: center;
      z-index: 999;
    }

    .status-chip {
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 25px;
      font-size: 14px;
      font-weight: 500;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .status-chip.connected {
      background: rgba(16, 185, 129, 0.2);
      border-color: #10b981;
      color: #10b981;
    }

    .status-chip.connecting {
      background: rgba(59, 130, 246, 0.2);
      border-color: #3b82f6;
      color: #3b82f6;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-chip.error {
      background: rgba(239, 68, 68, 0.2);
      border-color: #ef4444;
      color: #ef4444;
    }

    /* ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ */
    .back-to-live {
      position: fixed;
      bottom: 32px;
      right: 32px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      z-index: 998;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.3);
      transition: all 0.3s ease;
      display: none;
      align-items: center;
      gap: 8px;
      animation: bounce-gentle 2s ease-in-out infinite;
    }

    .back-to-live:hover {
      background: #059669;
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(16, 185, 129, 0.4);
    }

    @keyframes bounce-gentle {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-4px); }
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* ğŸ¯ ë©”ì¸ ìº¡ì…˜ ë·°ì–´ - ì™„ì „í•œ ê°€ìš´ë° ì •ë ¬ */
    #viewer {
      height: 100vh;
      width: 100%;
      padding: 0;
      overflow-y: auto;
      background: transparent;
      scroll-behavior: smooth;
      display: flex;
      align-items: center;      /* ğŸ“ ìˆ˜ì§ ê°€ìš´ë° ì •ë ¬ */
      justify-content: center;  /* ğŸ“ ìˆ˜í‰ ê°€ìš´ë° ì •ë ¬ */
    }

    /* ìë§‰ ì»¨í…Œì´ë„ˆ */
    .caption-container {
      width: 100%;
      max-width: 1200px;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;  /* ìë§‰ë“¤ì€ ì¢Œì¸¡ ì •ë ¬ */
      gap: 0;
    }

    .caption-line {
      margin-bottom: 24px;
      line-height: 1.5;
      padding: 20px 32px;
      border-radius: 16px;
      transition: all 0.4s ease;
      word-break: keep-all;
      overflow-wrap: break-word;
      max-width: 90%;
      margin-left: 0;
      margin-right: auto;
      text-align: left;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
    }

    /* ì›ë¬¸ ìŠ¤íƒ€ì¼ */
    .caption-line.original {
      font-size: var(--original-font-size);
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-left: 3px solid rgba(255, 255, 255, 0.4);
      margin-bottom: 12px;
      font-weight: 300;
      max-width: 85%;
    }

    /* ë²ˆì—­ëœ ìë§‰ ìŠ¤íƒ€ì¼ */
    .caption-line.stable {
      font-size: var(--translation-font-size);
      color: #ffffff;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-left: 4px solid #10b981;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }

    /* ì‹¤ì‹œê°„ ì…ë ¥ ì¤‘ */
    .caption-line.unstable {
      font-size: calc(var(--translation-font-size) - 2px);
      color: #fbbf24;
      font-style: italic;
      font-weight: 400;
      background: rgba(251, 191, 36, 0.1);
      border: 1px solid rgba(251, 191, 36, 0.3);
      border-left: 4px solid #fbbf24;
      animation: breathe 2s ease-in-out infinite;
      max-width: 88%;
    }

    /* ë¹ˆ ìƒíƒœ - ê°€ìš´ë° ì •ë ¬ */
    .welcome-state {
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    .welcome-state .icon {
      font-size: 80px;
      margin-bottom: 32px;
      opacity: 0.8;
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
    }

    .welcome-state h1 {
      font-size: 36px;
      font-weight: 300;
      margin-bottom: 16px;
      color: #ffffff;
    }

    .welcome-state p {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 32px;
      line-height: 1.6;
    }

    .welcome-state .hint {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    /* ìŠ¤í¬ë¡¤ë°” ìŠ¤íƒ€ì¼ë§ */
    #viewer::-webkit-scrollbar {
      width: 8px;
    }

    #viewer::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    #viewer::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 4px;
    }

    #viewer::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    /* ë°˜ì‘í˜• ë””ìì¸ */
    @media (max-width: 768px) {
      .settings-panel {
        width: 100%;
      }

      .caption-container {
        padding: 20px;
      }

      .caption-line.stable {
        font-size: calc(var(--translation-font-size) * 0.8);
        padding: 16px 20px;
        max-width: 95%;
      }

      .caption-line.original {
        font-size: calc(var(--original-font-size) * 0.9);
        padding: 12px 16px;
      }

      .welcome-state h1 {
        font-size: 24px;
      }

      .welcome-state p {
        font-size: 16px;
      }

      .back-to-live {
        bottom: 100px;
        right: 20px;
        padding: 10px 16px;
        font-size: 13px;
      }
    }
  </style>
</head>

<body>
  <!-- í”Œë¡œíŒ… ì„¤ì • ë²„íŠ¼ -->
  <button class="settings-fab" id="settingsFab">âš™ï¸</button>

  <!-- ì„¤ì • íŒ¨ë„ -->
  <div class="settings-panel" id="settingsPanel">
    <h2>ì‹¤ì‹œê°„ ìë§‰ ì„¤ì •</h2>

    <div class="control-group">
      <label>ë§ˆì´í¬ ê¶Œí•œ</label>
      <button id="btnPerm">ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­</button>
    </div>

    <div class="control-group">
      <label>ì˜¤ë””ì˜¤ ì¥ì¹˜</label>
      <select id="selMic" disabled>
        <option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
      </select>
    </div>

    <!-- ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ ì¶”ê°€ -->
    <div class="control-group">
      <label>ğŸ“ ë²ˆì—­ ê¸€ì í¬ê¸°</label>
      <input type="range" id="fontSizeSlider" min="18" max="48" value="28" step="2" class="slider">
      <span id="fontSizeValue">28px</span>
    </div>

    <div class="control-group">
      <label>ğŸ“„ ì›ë¬¸ ê¸€ì í¬ê¸°</label>
      <input type="range" id="originalSizeSlider" min="12" max="24" value="16" step="1" class="slider">
      <span id="originalSizeValue">16px</span>
    </div>

    <div class="control-group">
      <label>ì œì–´</label>
      <button id="btnPause" style="display: none;">â¸ï¸ ì¼ì‹œì •ì§€</button>
      <button id="btnClear">ğŸ—‘ï¸ ìë§‰ ì§€ìš°ê¸°</button>
    </div>
  </div>

  <!-- ìƒíƒœ í‘œì‹œ -->
  <div class="status-overlay">
    <div id="status" class="status-chip">ëŒ€ê¸°ì¤‘</div>
    <div id="latency" class="status-chip" style="display: none;"></div>
  </div>

  <!-- ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ -->
  <button class="back-to-live" id="backToLive">
    ğŸ“º ì‹¤ì‹œê°„ìœ¼ë¡œ
    <span style="margin-left: 4px;">â¬‡ï¸</span>
  </button>

  <!-- ë©”ì¸ ìº¡ì…˜ ë·°ì–´ -->
  <div id="viewer">
    <div class="caption-container" id="captionContainer">
      <div class="welcome-state">
        <div class="icon">ğŸ™ï¸</div>
        <h1>ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ìë§‰</h1>
        <p>ì˜ì–´ë¡œ ë§í•˜ë©´ í•œêµ­ì–´ ìë§‰ì´<br>ì‹¤ì‹œê°„ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
        <div class="hint">
          <span>âš™ï¸</span>
          <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
        </div>
      </div>
    </div>
  </div>

<script>
// Bootstrap data
const BOOT = {{BOOTSTRAP_JSON}};

// Global state
let pc = null;
let dc = null;
let localStream = null;
let currentDeviceId = null;
let startTime = null;
let currentUnstableLine = null;
let responseInProgress = false;
let currentResponseId = null;
let pendingTranscript = null;
let pendingTranslation = '';
let lastProcessedTranscript = null;
let isPaused = false;

// DOM elements
const viewer = document.getElementById('viewer');
const captionContainer = document.getElementById('captionContainer');
const selMic = document.getElementById('selMic');
const statusEl = document.getElementById('status');
const latencyEl = document.getElementById('latency');
const btnPerm = document.getElementById('btnPerm');
const btnPause = document.getElementById('btnPause');
const btnClear = document.getElementById('btnClear');
const settingsFab = document.getElementById('settingsFab');
const settingsPanel = document.getElementById('settingsPanel');
const backToLiveBtn = document.getElementById('backToLive');

// ğŸ¨ í°íŠ¸ ì¡°ì ˆ ìŠ¬ë¼ì´ë” ìš”ì†Œ
const fontSizeSlider = document.getElementById('fontSizeSlider');
const fontSizeValue = document.getElementById('fontSizeValue');
const originalSizeSlider = document.getElementById('originalSizeSlider');
const originalSizeValue = document.getElementById('originalSizeValue');

// ğŸ¨ í°íŠ¸ í¬ê¸° ì¡°ì ˆ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
fontSizeSlider.oninput = (e) => {
  const size = e.target.value;
  document.documentElement.style.setProperty('--translation-font-size', `${size}px`);
  fontSizeValue.textContent = `${size}px`;
};

originalSizeSlider.oninput = (e) => {
  const size = e.target.value;
  document.documentElement.style.setProperty('--original-font-size', `${size}px`);
  originalSizeValue.textContent = `${size}px`;
};

// ì„¤ì • íŒ¨ë„ í† ê¸€
settingsFab.onclick = () => {
  settingsPanel.classList.toggle('open');
  settingsFab.classList.toggle('active');
};

// ì„¤ì • íŒ¨ë„ ì™¸ë¶€ í´ë¦­ì‹œ ë‹«ê¸°
document.addEventListener('click', (e) => {
  if (!settingsPanel.contains(e.target) && !settingsFab.contains(e.target)) {
    settingsPanel.classList.remove('open');
    settingsFab.classList.remove('active');
  }
});

// ìë§‰ ì§€ìš°ê¸°
btnClear.onclick = () => {
  clearViewer();
};

// ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼
backToLiveBtn.onclick = () => {
  viewer.scrollTo({
    top: viewer.scrollHeight,
    behavior: 'smooth'
  });
};

// Utility functions
function logStatus(status, className = '') {
  statusEl.textContent = status;
  statusEl.className = `status-chip ${className}`;
}

function logLatency(ms) {
  if (ms > 0) {
    latencyEl.style.display = 'block';
    latencyEl.textContent = `${Math.round(ms)}ms`;
  } else {
    latencyEl.style.display = 'none';
  }
}

// í† ìŠ¤íŠ¸ ë©”ì‹œì§€ (ê°„ì†Œí™”)
function showToast(message, type = 'info') {
  if (type === 'error' || type === 'warning') {
    const toast = document.createElement('div');
    toast.style.cssText = `
      position: fixed; top: 24px; left: 50%;
      transform: translateX(-50%);
      background: ${type === 'error' ? '#ef4444' : '#f59e0b'};
      color: white; padding: 16px 24px; border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      z-index: 1002; font-size: 14px; font-weight: 500;
      opacity: 0; transition: opacity 0.3s ease;
    `;
    toast.textContent = message;
    document.body.appendChild(toast);

    setTimeout(() => toast.style.opacity = '1', 10);
    setTimeout(() => {
      toast.style.opacity = '0';
      setTimeout(() => document.body.removeChild(toast), 300);
    }, 3000);
  }
}

// Permission and device handling
async function ensurePermission() {
  try {
    logStatus('ê¶Œí•œ ìš”ì²­ ì¤‘', 'connecting');

    const permissionStatus = await navigator.permissions.query({name: 'microphone'});
    if (permissionStatus.state === 'denied') {
      throw new Error('ë§ˆì´í¬ ê¶Œí•œì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }

    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: 24000
      }
    });

    stream.getTracks().forEach(track => track.stop());
    logStatus('ê¶Œí•œ í—ˆìš©ë¨', 'connected');
    return true;
  } catch (error) {
    logStatus('ê¶Œí•œ í•„ìš”', 'error');
    showToast('ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤', 'warning');
    return false;
  }
}

async function listMics() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(d => d.kind === 'audioinput');

    selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';

    if (audioInputs.length === 0) {
      selMic.innerHTML = '<option value="">ë§ˆì´í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤</option>';
      return;
    }

    audioInputs.forEach((device, index) => {
      const option = document.createElement('option');
      option.value = device.deviceId;
      option.textContent = device.label || `ë§ˆì´í¬ ${index + 1}`;
      selMic.appendChild(option);
    });

    if (!currentDeviceId && audioInputs.length > 0) {
      const defaultDevice = audioInputs.find(d => d.deviceId === 'default') || audioInputs[0];
      currentDeviceId = defaultDevice.deviceId;
      selMic.value = currentDeviceId;
    }

    selMic.disabled = false;
  } catch (error) {
    showToast('ì¥ì¹˜ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', 'error');
  }
}

async function getStream(deviceId) {
  try {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    const constraints = {
      audio: {
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: 24000,
        channelCount: 1
      }
    };

    localStream = await navigator.mediaDevices.getUserMedia(constraints);
    currentDeviceId = deviceId;
    return localStream;
  } catch (error) {
    throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
  }
}

// ğŸ”§ ì™„ì „ ìˆ˜ì •ëœ ìë§‰ ì¶”ê°€ í•¨ìˆ˜
function appendLine(text, className = 'stable') {
  if (!text || !text.trim()) return;

  const welcomeState = captionContainer.querySelector('.welcome-state');
  if (welcomeState) {
    welcomeState.remove();
  }

  const isUserScrolling = viewer.scrollTop < (viewer.scrollHeight - viewer.clientHeight - 100);

  if (className === 'unstable') {
    if (!currentUnstableLine) {
      currentUnstableLine = document.createElement('div');
      currentUnstableLine.className = `caption-line ${className}`;
      currentUnstableLine.textContent = '';
      captionContainer.appendChild(currentUnstableLine);  // ğŸ“ captionContainer ì‚¬ìš©
    }
    const needsSpace = currentUnstableLine.textContent.length > 0 && !text.startsWith(' ');
    currentUnstableLine.textContent += (needsSpace ? ' ' : '') + text.trim();
  } else {
    if (currentUnstableLine) {
      currentUnstableLine.className = `caption-line ${className}`;
      currentUnstableLine.textContent = text.trim();
      currentUnstableLine = null;
    } else {
      const div = document.createElement('div');
      div.className = `caption-line ${className}`;
      div.textContent = text.trim();
      captionContainer.appendChild(div);  // ğŸ“ captionContainer ì‚¬ìš©
    }
  }

  // ìë™ ìŠ¤í¬ë¡¤
  if (!isUserScrolling) {
    requestAnimationFrame(() => {
      viewer.scrollTo({
        top: viewer.scrollHeight,
        behavior: 'smooth'
      });
    });
  }

  // ìë§‰ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
  const captionLines = captionContainer.querySelectorAll('.caption-line');
  if (captionLines.length > 100) {
    captionLines[0].remove();
  }
}

// ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ í•¸ë“¤ë§
viewer.addEventListener('scroll', () => {
  const isAtBottom = viewer.scrollTop >= (viewer.scrollHeight - viewer.clientHeight - 100);

  if (!isAtBottom) {
    backToLiveBtn.style.display = 'flex';
  } else {
    backToLiveBtn.style.display = 'none';
  }
});

// ğŸ”§ ìˆ˜ì •ëœ clearViewer í•¨ìˆ˜
function clearViewer() {
  captionContainer.innerHTML = `
    <div class="welcome-state">
      <div class="icon">ğŸ™ï¸</div>
      <h1>ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ìë§‰</h1>
      <p>ì˜ì–´ë¡œ ë§í•˜ë©´ í•œêµ­ì–´ ìë§‰ì´<br>ì‹¤ì‹œê°„ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
      <div class="hint">
        <span>âš™ï¸</span>
        <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
      </div>
    </div>
  `;
  currentUnstableLine = null;
  backToLiveBtn.style.display = 'none';
}

function displayTranscriptAndTranslation(transcript, translation) {
  // ì›ë¬¸ í‘œì‹œ
  appendLine(transcript, 'original');

  // ë²ˆì—­ í‘œì‹œ
  if (translation &&
      !translation.includes('[ë²ˆì—­') &&
      !translation.includes('[ì˜¤ë¥˜') &&
      translation.trim().length > 0) {
    appendLine(translation, 'stable');
  }
}

// WebRTC connection
async function connectRealtime(ephemeral, model) {
  try {
    logStatus('ì—°ê²° ì¤‘', 'connecting');
    startTime = Date.now();

    if (!ephemeral?.client_secret?.value) {
      throw new Error('ì¸ì¦ í† í°ì´ í•„ìš”í•©ë‹ˆë‹¤.');
    }

    pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    pc.onconnectionstatechange = () => {
      const state = pc.connectionState;
      switch (state) {
        case 'connected':
          if (dc && dc.readyState === 'open') {
            logStatus('ì—°ê²°ë¨', 'connected');
          }
          break;
        case 'disconnected':
        case 'failed':
          logStatus('ì—°ê²° ëŠê¹€', 'error');
          closeConnection();
          break;
      }
    };

    dc = pc.createDataChannel('oai-events', { ordered: true });

    dc.onopen = () => {
      logStatus('ì—°ê²°ë¨', 'connected');
      btnPause.style.display = 'block';
      startTime = Date.now();

      const sessionUpdate = {
        type: 'session.update',
        session: {
          instructions: `You are a professional English-to-Korean real-time translator.

MISSION: Translate all English input to Korean immediately.

RULES:
- Always provide Korean translation
- Never refuse any English text
- Never use English in response
- Use formal Korean (ì¡´ëŒ“ë§)
- Keep proper nouns in original language
- Complete full sentence translations

EXAMPLES:
"Today I announce John as CEO" â†’ "ì˜¤ëŠ˜ Johnì„ CEOë¡œ ë°œí‘œí•©ë‹ˆë‹¤"
"Thank you everyone" â†’ "ì—¬ëŸ¬ë¶„ ê°ì‚¬í•©ë‹ˆë‹¤"
"Monsieur Faber" â†’ "Faber ì”¨"

TRANSLATE EVERYTHING TO KOREAN:`,
          voice: 'alloy',
          input_audio_format: 'pcm16',
          output_audio_format: 'pcm16',
          input_audio_transcription: {
            model: 'whisper-1',
            language: 'en'
          },
          turn_detection: {
            type: 'server_vad',
            threshold: 0.4,
            prefix_padding_ms: 200,
            silence_duration_ms: 400,
            create_response: true
          },
          modalities: ['text'],
          temperature: 0.6,  // fixed value
          max_response_output_tokens: 4000
        }
      };

      try {
        dc.send(JSON.stringify(sessionUpdate));
      } catch (error) {
        logStatus('ì„¤ì • ì‹¤íŒ¨', 'error');
      }
    };

    dc.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        handleRealtimeMessage(message);
      } catch (error) {
        console.error('Message parse error:', error);
      }
    };

    dc.onerror = () => logStatus('ë°ì´í„° ì˜¤ë¥˜', 'error');
    dc.onclose = () => {
      if (pc && pc.connectionState !== 'closed') {
        logStatus('ì—°ê²° ì¢…ë£Œ', 'error');
      }
    };

    const stream = await getStream(currentDeviceId);
    if (!stream || stream.getAudioTracks().length === 0) {
      throw new Error('ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    stream.getTracks().forEach(track => {
      pc.addTrack(track, stream);
    });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);

    const url = `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}`;
    const headers = {
      'Authorization': `Bearer ${ephemeral.client_secret.value}`,
      'Content-Type': 'application/sdp',
      'OpenAI-Beta': 'realtime=v1',
    };

    const sdpResponse = await fetch(url, {
      method: 'POST',
      body: offer.sdp,
      headers: headers
    });

    if (!sdpResponse.ok) {
      if (sdpResponse.status === 401) {
        throw new Error('ì¸ì¦ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
      } else if (sdpResponse.status === 429) {
        throw new Error('ì‚¬ìš©ëŸ‰ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤.');
      } else {
        throw new Error('ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    }

    const answerSdp = await sdpResponse.text();
    const answer = { type: 'answer', sdp: answerSdp };
    await pc.setRemoteDescription(answer);

  } catch (error) {
    logStatus('ì—°ê²° ì‹¤íŒ¨', 'error');
    showToast(error.message || 'ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
    closeConnection();
    throw error;
  }
}

function handleRealtimeMessage(message) {
  if (isPaused && !message.type?.includes('error')) {
    return;
  }

  // ë””ë²„ê¹… ë¡œê·¸
  console.log('[Realtime]', message.type, message);

  // ì§€ì—°ì‹œê°„ ì¸¡ì •
  if (startTime && !latencyEl.textContent) {
    const isContent = (message.type?.includes('delta') || message.type?.includes('transcription')) &&
      (message.delta || message.text || message.transcript);
    if (isContent) {
      const latency = Date.now() - startTime;
      logLatency(latency);
      startTime = null;
    }
  }

  switch (message.type) {
    case 'conversation.item.input_audio_transcription.completed':
      if (message.transcript) {
        const transcript = message.transcript.trim();

        if (transcript === lastProcessedTranscript || transcript.length < 3) {
          break;
        }

        lastProcessedTranscript = transcript;
        console.log('[Transcription] New:', transcript);

        if (pendingTranscript && pendingTranscript !== transcript) {
          displayTranscriptAndTranslation(pendingTranscript, pendingTranslation || '');
        }

        pendingTranscript = transcript;
        pendingTranslation = '';

        if (dc && dc.readyState === 'open' && !responseInProgress) {
          responseInProgress = true;
          dc.send(JSON.stringify({ type: 'response.create' }));
          console.log('[Translation] Requested for:', transcript);

          setTimeout(() => {
            if (responseInProgress && pendingTranscript === transcript) {
              console.warn('[Translation] Timeout');
              responseInProgress = false;
              currentResponseId = null;
              if (pendingTranscript) {
                displayTranscriptAndTranslation(pendingTranscript, '');
                pendingTranscript = null;
                pendingTranslation = '';
              }
            }
          }, 8000);
        }
      }
      break;

    case 'response.text.delta':
      if (message.delta && pendingTranscript) {
        const cleanDelta = message.delta.replace(/^["']|["']$/g, '');
        if (!cleanDelta.toLowerCase().includes('cannot') &&
            !cleanDelta.toLowerCase().includes('sorry')) {
          pendingTranslation += cleanDelta;
          console.log('[Delta]', cleanDelta);
        }
      }
      break;

    case 'response.text.done':
      if (message.text && pendingTranscript) {
        let cleanText = message.text.replace(/^["']|["']$/g, '').trim();
        console.log('[Done]', cleanText);

        if (cleanText.toLowerCase().includes('cannot assist') ||
            cleanText.toLowerCase().includes('sorry, but i can\'t')) {
          cleanText = '';
        }

        const finalTranslation = cleanText || pendingTranslation.trim();
        console.log('[Final Translation]', finalTranslation);

        if (finalTranslation && finalTranslation.length > 0) {
          displayTranscriptAndTranslation(pendingTranscript, finalTranslation);
        } else {
          displayTranscriptAndTranslation(pendingTranscript, '');
        }

        pendingTranscript = null;
        pendingTranslation = '';
      }
      break;

    case 'response.created':
      currentResponseId = message.response?.id || Date.now().toString();
      responseInProgress = true;
      console.log('[Response] Created:', currentResponseId);
      break;

    case 'response.done':
      responseInProgress = false;
      currentResponseId = null;
      console.log('[Response] Done');
      break;

    case 'input_audio_buffer.speech_started':
      logStatus('ìŒì„± ì¸ì‹ ì¤‘', 'connecting');
      break;

    case 'input_audio_buffer.speech_stopped':
      logStatus('ì²˜ë¦¬ ì¤‘', 'connecting');
      break;

    case 'error':
      console.error('[Error]', message.error);
      logStatus('ì˜¤ë¥˜', 'error');
      showToast('ì„œë¹„ìŠ¤ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤', 'error');
      break;

    default:
      console.log('[Unhandled]', message.type);
      break;
  }
}

function closeConnection() {
  try {
    if (dc) { dc.close(); dc = null; }
    if (pc) { pc.close(); pc = null; }
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    currentUnstableLine = null;
    responseInProgress = false;
    currentResponseId = null;
    pendingTranscript = null;
    pendingTranslation = '';
    lastProcessedTranscript = null;
    isPaused = false;

    btnPause.style.display = 'none';
    btnPause.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
    logStatus('ëŒ€ê¸°ì¤‘', '');
    logLatency(0);
    backToLiveBtn.style.display = 'none';
  } catch (error) {
    // ì¡°ìš©íˆ ì²˜ë¦¬
  }
}

// Event handlers
btnPerm.onclick = async () => {
  const success = await ensurePermission();
  if (success) {
    await listMics();
  }
};

btnPause.onclick = () => {
  if (isPaused) {
    isPaused = false;
    btnPause.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
    logStatus('ì—°ê²°ë¨', 'connected');
  } else {
    isPaused = true;
    btnPause.textContent = 'â–¶ï¸ ì¬ê°œ';
    logStatus('ì¼ì‹œì •ì§€', 'connecting');
    clearViewer();
  }
};

selMic.onchange = async (event) => {
  const newDeviceId = event.target.value;
  if (!newDeviceId) return;

  const wasConnected = pc && pc.connectionState === 'connected';
  currentDeviceId = newDeviceId;

  if (wasConnected) {
    try {
      logStatus('ì¥ì¹˜ ë³€ê²½ ì¤‘', 'connecting');
      const newStream = await getStream(newDeviceId);
      const audioTrack = newStream.getAudioTracks()[0];
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'audio');

      if (sender && audioTrack) {
        await sender.replaceTrack(audioTrack);
        logStatus('ì—°ê²°ë¨', 'connected');
      }
    } catch (error) {
      logStatus('ì¥ì¹˜ ë³€ê²½ ì‹¤íŒ¨', 'error');
      selMic.value = currentDeviceId;
    }
  }
};

// Bootstrap
(async () => {
  try {
    if (BOOT.action === 'start' && BOOT.ephemeral) {
      const hasPermission = await ensurePermission();
      if (hasPermission) {
        await listMics();
        await connectRealtime(BOOT.ephemeral, BOOT.model);
      }
    } else if (BOOT.action === 'stop') {
      closeConnection();
      clearViewer();
    } else {
      logStatus('ëŒ€ê¸°ì¤‘', '');
    }
  } catch (error) {
    logStatus('ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
  }
})();

// Cleanup
window.addEventListener('beforeunload', () => {
  closeConnection();
});

// ìŠ¤í¬ë¡¤ ìƒíƒœ ì¶”ì  ê°œì„ 
let scrollTimer = null;
let isAutoScrolling = false;

// ê°œì„ ëœ ìë™ ìŠ¤í¬ë¡¤ í•¨ìˆ˜
function autoScrollToBottom() {
  if (!isUserScrolling()) {
    isAutoScrolling = true;
    viewer.scrollTo({
      top: viewer.scrollHeight,
      behavior: 'smooth'
    });

    // ìŠ¤í¬ë¡¤ ì™„ë£Œ í›„ í”Œë˜ê·¸ í•´ì œ
    setTimeout(() => {
      isAutoScrolling = false;
    }, 500);
  }
}

// ì‚¬ìš©ì ìŠ¤í¬ë¡¤ ê°ì§€ ê°œì„ 
function isUserScrolling() {
  const threshold = 100;
  return viewer.scrollTop < (viewer.scrollHeight - viewer.clientHeight - threshold);
}

// ê°œì„ ëœ ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ í•¸ë“¤ë§
viewer.addEventListener('scroll', () => {
  // ìë™ ìŠ¤í¬ë¡¤ ì¤‘ì—ëŠ” ë²„íŠ¼ í‘œì‹œ ì•ˆ í•¨
  if (isAutoScrolling) {
    return;
  }

  const isAtBottom = viewer.scrollTop >= (viewer.scrollHeight - viewer.clientHeight - 50);

  // ìŠ¤í¬ë¡¤ íƒ€ì´ë¨¸ë¡œ ë””ë°”ìš´ìŠ¤ ì²˜ë¦¬
  clearTimeout(scrollTimer);
  scrollTimer = setTimeout(() => {
    if (!isAtBottom) {
      backToLiveBtn.style.display = 'flex';
    } else {
      backToLiveBtn.style.display = 'none';
    }
  }, 100);
});

// ì‹¤ì‹œê°„ìœ¼ë¡œ ë²„íŠ¼ ê°œì„ 
backToLiveBtn.onclick = () => {
  isAutoScrolling = true;
  viewer.scrollTo({
    top: viewer.scrollHeight,
    behavior: 'smooth'
  });

  setTimeout(() => {
    isAutoScrolling = false;
    backToLiveBtn.classList.remove('show');
  }, 500);
};

function clearViewer() {
  captionContainer.innerHTML = `
    <div class="welcome-state">
      <div class="icon">ğŸ™ï¸</div>
      <h1>ì‹¤ì‹œê°„ ì˜ì–´-í•œêµ­ì–´ ìë§‰</h1>
      <p>ì˜ì–´ë¡œ ë§í•˜ë©´ í•œêµ­ì–´ ìë§‰ì´<br>ì‹¤ì‹œê°„ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤</p>
      <div class="hint">
        <span>âš™ï¸</span>
        <span>ìš°ìƒë‹¨ ì„¤ì •ì—ì„œ ë§ˆì´í¬ë¥¼ í™œì„±í™”í•˜ì„¸ìš”</span>
      </div>
    </div>
  `;
  currentUnstableLine = null;
  backToLiveBtn.classList.remove('show');
}

</script>
</body>
</html>
